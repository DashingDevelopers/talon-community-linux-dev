<!DOCTYPE html>
        <html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
        <head>
          <meta charset="utf-8" />
          <meta name="generator" content="pandoc" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
          <title>cheatsheet</title>
          <style>
            code{white-space: pre-wrap;}
            span.smallcaps{font-variant: small-caps;}
            span.underline{text-decoration: underline;}
            div.column{display: inline-block; vertical-align: top; width: 50%;}
            div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
            ul.task-list{list-style: none;}
          </style>
          <link rel="stylesheet" href="cheatsheet.css" />
        </head>
        <body><h1> Talon Cheat Sheet </h1>

<h1> user.letter </h1>

<h2>command word  {list_name}</h2> 

<p>keyt: air, v: a</p>
<p>keyt: bat, v: b</p>
<p>keyt: cap, v: c</p>
<p>keyt: drum, v: d</p>
<p>keyt: each, v: e</p>
<p>keyt: fine, v: f</p>
<p>keyt: gust, v: g</p>
<p>keyt: harp, v: h</p>
<p>keyt: sit, v: i</p>
<p>keyt: jury, v: j</p>
<p>keyt: crunch, v: k</p>
<p>keyt: look, v: l</p>
<p>keyt: made, v: m</p>
<p>keyt: near, v: n</p>
<p>keyt: odd, v: o</p>
<p>keyt: pit, v: p</p>
<p>keyt: quench, v: q</p>
<p>keyt: red, v: r</p>
<p>keyt: sun, v: s</p>
<p>keyt: trap, v: t</p>
<p>keyt: urge, v: u</p>
<p>keyt: vest, v: v</p>
<p>keyt: whale, v: w</p>
<p>keyt: plex, v: x</p>
<p>keyt: yank, v: y</p>
<p>keyt: zip, v: z</p>


<h1> user.symbol_key </h1>

<h2>command word  {list_name}</h2> 

<p>keyt: dot, v: .</p>
<p>keyt: point, v: .</p>
<p>keyt: quote, v: '</p>
<p>keyt: question, v: ?</p>
<p>keyt: apostrophe, v: '</p>
<p>keyt: L square, v: [</p>
<p>keyt: left square, v: [</p>
<p>keyt: brack, v: [</p>
<p>keyt: bracket, v: [</p>
<p>keyt: left bracket, v: [</p>
<p>keyt: square, v: [</p>
<p>keyt: R square, v: ]</p>
<p>keyt: right square, v: ]</p>
<p>keyt: r brack, v: ]</p>
<p>keyt: r bracket, v: ]</p>
<p>keyt: right bracket, v: ]</p>
<p>keyt: slash, v: /</p>
<p>keyt: backslash, v: \</p>
<p>keyt: minus, v: -</p>
<p>keyt: dash, v: -</p>
<p>keyt: equals, v: =</p>
<p>keyt: plus, v: +</p>
<p>keyt: grave, v: `</p>
<p>keyt: tilde, v: ~</p>
<p>keyt: bang, v: !</p>
<p>keyt: down score, v: _</p>
<p>keyt: underscore, v: _</p>
<p>keyt: paren, v: (</p>
<p>keyt: brace, v: {</p>
<p>keyt: left brace, v: {</p>
<p>keyt: curly bracket, v: {</p>
<p>keyt: left curly bracket, v: {</p>
<p>keyt: r brace, v: }</p>
<p>keyt: right brace, v: }</p>
<p>keyt: r curly bracket, v: }</p>
<p>keyt: right curly bracket, v: }</p>
<p>keyt: angle, v: <</p>
<p>keyt: left angle, v: <</p>
<p>keyt: less than, v: <</p>
<p>keyt: rangle, v: ></p>
<p>keyt: R angle, v: ></p>
<p>keyt: right angle, v: ></p>
<p>keyt: greater than, v: ></p>
<p>keyt: star, v: *</p>
<p>keyt: hash, v: #</p>
<p>keyt: percent, v: %</p>
<p>keyt: caret, v: ^</p>
<p>keyt: amper, v: &</p>
<p>keyt: pipe, v: |</p>
<p>keyt: dub quote, v: "</p>
<p>keyt: double quote, v: "</p>
<p>keyt: dollar, v: $</p>
<p>keyt: pound, v: £</p>
<p>keyt: `, v: `</p>
<p>keyt: ,, v: ,</p>
<p>keyt: back tick, v: `</p>
<p>keyt: comma, v: ,</p>
<p>keyt: coma, v: ,</p>
<p>keyt: period, v: .</p>
<p>keyt: full stop, v: .</p>
<p>keyt: semicolon, v: ;</p>
<p>keyt: colon, v: :</p>
<p>keyt: forward slash, v: /</p>
<p>keyt: question mark, v: ?</p>
<p>keyt: exclamation mark, v: !</p>
<p>keyt: exclamation point, v: !</p>
<p>keyt: asterisk, v: *</p>
<p>keyt: hash sign, v: #</p>
<p>keyt: number sign, v: #</p>
<p>keyt: percent sign, v: %</p>
<p>keyt: at sign, v: @</p>
<p>keyt: and sign, v: &</p>
<p>keyt: ampersand, v: &</p>
<p>keyt: dollar sign, v: $</p>
<p>keyt: pound sign, v: £</p>
<p>keyt: hyphen, v: -</p>
<p>keyt: L paren, v: (</p>
<p>keyt: left paren, v: (</p>
<p>keyt: R paren, v: )</p>
<p>keyt: right paren, v: )</p>


<h1> user.punctuation </h1>

<h2>command word  {list_name}</h2> 

<p>keyt: `, v: `</p>
<p>keyt: ,, v: ,</p>
<p>keyt: back tick, v: `</p>
<p>keyt: comma, v: ,</p>
<p>keyt: coma, v: ,</p>
<p>keyt: period, v: .</p>
<p>keyt: full stop, v: .</p>
<p>keyt: semicolon, v: ;</p>
<p>keyt: colon, v: :</p>
<p>keyt: forward slash, v: /</p>
<p>keyt: question mark, v: ?</p>
<p>keyt: exclamation mark, v: !</p>
<p>keyt: exclamation point, v: !</p>
<p>keyt: asterisk, v: *</p>
<p>keyt: hash sign, v: #</p>
<p>keyt: number sign, v: #</p>
<p>keyt: percent sign, v: %</p>
<p>keyt: at sign, v: @</p>
<p>keyt: and sign, v: &</p>
<p>keyt: ampersand, v: &</p>
<p>keyt: dollar sign, v: $</p>
<p>keyt: pound sign, v: £</p>
<p>keyt: hyphen, v: -</p>
<p>keyt: L paren, v: (</p>
<p>keyt: left paren, v: (</p>
<p>keyt: R paren, v: )</p>
<p>keyt: right paren, v: )</p>


<h2>formatters</h2> 

command word  user.formatters  
<p>key:all cap,ex: EXAMPLE OF FORMATTING WITH ALL CAP</p><p>key:all down,ex: example of formatting with all down</p><p>key:camel,ex: exampleOfFormattingWithCamel</p><p>key:dotted,ex: example.of.formatting.with.dotted</p><p>key:dub string,ex: "example of formatting with dub string"</p><p>key:dunder,ex: __example__offormattingwithdunder</p><p>key:hammer,ex: ExampleOfFormattingWithHammer</p><p>key:kebab,ex: example-of-formatting-with-kebab</p><p>key:packed,ex: example::of::formatting::with::packed</p><p>key:padded,ex:  example of formatting with padded </p><p>key:slasher,ex: /example/of/formatting/with/slasher</p><p>key:smash,ex: exampleofformattingwithsmash</p><p>key:snake,ex: example_of_formatting_with_snake</p><p>key:string,ex: 'example of formatting with string'</p><p>key:say,ex: example of formatting with say</p><p>key:speak,ex: example of formatting with speak</p><p>key:sentence,ex: Example of formatting with sentence</p><p>key:title,ex: Example of Formatting With Title</p><h2>cursorless</h2><p>rule: &lt;user.cursorless_action_or_ide_command&gt; &lt;user.cursorless_target&gt; , imp:user.private_cursorless_action_or_ide_command(cursorless_action_or_ide_command, cursorless_target)
		</p><p>rule: {user.cursorless_bring_move_action} &lt;user.cursorless_bring_move_targets&gt; , imp:user.private_cursorless_bring_move(cursorless_bring_move_action, cursorless_bring_move_targets)
		</p><p>rule: {user.cursorless_swap_action} &lt;user.cursorless_swap_targets&gt; , imp:user.private_cursorless_swap(cursorless_swap_targets)
		</p><p>rule: {user.cursorless_paste_action} &lt;user.cursorless_destination&gt; , imp:user.private_cursorless_paste(cursorless_destination)
		</p><p>rule: {user.cursorless_reformat_action} &lt;user.formatters&gt; at &lt;user.cursorless_target&gt; , imp:user.private_cursorless_reformat(cursorless_target, formatters)
		</p><p>rule: {user.cursorless_call_action} &lt;user.cursorless_target&gt; on &lt;user.cursorless_target&gt; , imp:user.private_cursorless_call(cursorless_target_1, cursorless_target_2)
		</p><p>rule: &lt;user.cursorless_wrapper_paired_delimiter&gt; {user.cursorless_wrap_action} &lt;user.cursorless_target&gt; , imp:user.private_cursorless_wrap_with_paired_delimiter(cursorless_wrap_action, cursorless_target, cursorless_wrapper_paired_delimiter)
		</p><p>rule: {user.cursorless_insert_snippet_action} &lt;user.cursorless_insertion_snippet&gt; , imp:user.private_cursorless_insert_snippet(cursorless_insertion_snippet)
		</p><p>rule: {user.cursorless_insert_snippet_action} {user.cursorless_insertion_snippet_single_phrase} &lt;user.text&gt; [{user.cursorless_phrase_terminator}] , imp:user.private_cursorless_insert_snippet_with_phrase(cursorless_insertion_snippet_single_phrase, text)
		</p><p>rule: {user.cursorless_wrapper_snippet} {user.cursorless_wrap_action} &lt;user.cursorless_target&gt; , imp:user.private_cursorless_wrap_with_snippet(cursorless_wrap_action, cursorless_target, cursorless_wrapper_snippet)
		</p><p>rule: {user.cursorless_show_scope_visualizer} &lt;user.cursorless_scope_type&gt; [{user.cursorless_visualization_type}] , imp:user.private_cursorless_show_scope_visualizer(cursorless_scope_type, cursorless_visualization_type or "content")</p><p>rule: {user.cursorless_hide_scope_visualizer} , imp:user.private_cursorless_hide_scope_visualizer()
		</p><p>rule: {user.cursorless_homophone} settings , imp:user.private_cursorless_show_settings_in_ide()
		</p><p>rule: bar {user.cursorless_homophone} , imp:user.private_cursorless_show_sidebar()</p><h2>cursorless global</h2><p>rule: {user.cursorless_homophone} (reference | ref | cheatsheet | cheat sheet) , imp:user.private_cursorless_cheat_sheet_show_html()</p><p>rule: {user.cursorless_homophone} (instructions | docks | help) | help {user.cursorless_homophone} , imp:user.private_cursorless_open_instructions()</p><h2>direct clicking</h2><p>rule: &lt;user.rango_target&gt; , imp:user.rango_command_with_target("directClickElement", rango_target)</p><h2>rango</h2><p>rule: click &lt;user.rango_target&gt; , imp:user.rango_command_with_target("clickElement", rango_target)
		
		# Focus</p><p>rule: focus &lt;user.rango_target&gt; , imp:user.rango_command_with_target("focusElement", rango_target)
		</p><p>rule: go input , imp:user.rango_command_without_target("focusFirstInput")
		
		# Focus and Enter</p><p>rule: flick &lt;user.rango_target&gt; , imp:user.rango_command_with_target("focusElement", rango_target)
		key(enter)
		
		# Focus tab</p><p>rule: (go tab | slot) &lt;user.rango_tab_marker&gt; , imp:user.rango_command_with_target("activateTab", rango_tab_marker)</p><p>rule: tab marker refresh , imp:user.rango_command_without_target("refreshTabMarkers")</p><p>rule: blank &lt;user.rango_target&gt; , imp:user.rango_command_with_target("openInNewTab", rango_target)</p><p>rule: stash &lt;user.rango_target&gt; , imp:user.rango_command_with_target("openInBackgroundTab", rango_target)
		
		# Navigation</p><p>rule: go root , imp:user.rango_command_without_target("navigateToPageRoot")</p><p>rule: page next , imp:user.rango_command_without_target("navigateToNextPage")</p><p>rule: page last , imp:user.rango_command_without_target("navigateToPreviousPage")</p><p>rule: tab split , imp:user.rango_command_without_target("moveCurrentTabToNewWindow")</p><p>rule: tab back , imp:user.rango_command_without_target("focusPreviousTab")</p><p>rule: visit {user.website} , imp:user.rango_command_without_target("focusOrCreateTabByUrl", website)</p><p>rule: tab hunt &lt;user.text&gt; , imp:user.rango_command_without_target("focusTabByText", text)</p><p>rule: tab ahead , imp:user.rango_command_without_target("cycleTabsByText", 1)</p><p>rule: tab behind , imp:user.rango_command_without_target("cycleTabsByText", -1)</p><p>rule: tab close other , imp:user.rango_command_without_target("closeOtherTabsInWindow")</p><p>rule: tab close left , imp:user.rango_command_without_target("closeTabsToTheLeftInWindow")</p><p>rule: tab close right , imp:user.rango_command_without_target("closeTabsToTheRightInWindow")</p><p>rule: tab close first [&lt;number_small&gt;] , imp:user.rango_command_without_target("closeTabsLeftEndInWindow", number_small or 1)</p><p>rule: tab close final [&lt;number_small&gt;] , imp:user.rango_command_without_target("closeTabsRightEndInWindow", number_small or 1)</p><p>rule: tab close previous [&lt;number_small&gt;] , imp:user.rango_command_without_target("closePreviousTabsInWindow", number_small or 1)</p><p>rule: tab close next [&lt;number_small&gt;] , imp:user.rango_command_without_target("closeNextTabsInWindow", number_small or 1)
		
		# Clone tab</p><p>rule: tab clone , imp:user.rango_command_without_target("cloneCurrentTab")</p><p>rule: hover &lt;user.rango_target&gt; , imp:user.rango_command_with_target("hoverElement", rango_target)</p><p>rule: dismiss , imp:user.rango_command_without_target("unhoverAll")</p><p>rule: show &lt;user.rango_target&gt; , imp:user.rango_command_with_target("showLink", rango_target)
		
		# Scroll</p><p>rule: upper , imp:user.rango_command_without_target("scrollUpPage")</p><p>rule: upper &lt;number&gt; , imp:user.rango_command_without_target("scrollUpPage", number)</p><p>rule: upper all , imp:user.rango_command_without_target("scrollUpPage", 9999)</p><p>rule: tiny up , imp:user.rango_command_without_target("scrollUpPage", 0.2)</p><p>rule: downer , imp:user.rango_command_without_target("scrollDownPage")</p><p>rule: downer &lt;number&gt; , imp:user.rango_command_without_target("scrollDownPage", number)</p><p>rule: downer all , imp:user.rango_command_without_target("scrollDownPage", 9999)</p><p>rule: tiny down , imp:user.rango_command_without_target("scrollDownPage", 0.2)</p><p>rule: scroll left , imp:user.rango_command_without_target("scrollLeftPage")</p><p>rule: scroll left all , imp:user.rango_command_without_target("scrollLeftPage", 9999)</p><p>rule: tiny left , imp:user.rango_command_without_target("scrollLeftPage", 0.2)</p><p>rule: scroll right , imp:user.rango_command_without_target("scrollRightPage")</p><p>rule: scroll right all , imp:user.rango_command_without_target("scrollRightPage", 9999)</p><p>rule: tiny right , imp:user.rango_command_without_target("scrollRightPage", 0.2)</p><p>rule: upper left , imp:user.rango_command_without_target("scrollUpLeftAside")</p><p>rule: upper left all , imp:user.rango_command_without_target("scrollUpLeftAside", 9999)</p><p>rule: downer left , imp:user.rango_command_without_target("scrollDownLeftAside")</p><p>rule: downer left all , imp:user.rango_command_without_target("scrollDownLeftAside", 9999)</p><p>rule: upper right , imp:user.rango_command_without_target("scrollUpRightAside")</p><p>rule: upper right all , imp:user.rango_command_without_target("scrollUpRightAside", 9999)</p><p>rule: downer right , imp:user.rango_command_without_target("scrollDownRightAside")</p><p>rule: downer right all , imp:user.rango_command_without_target("scrollDownRightAside", 9999)</p><p>rule: upper &lt;user.rango_target&gt; , imp:user.rango_command_with_target("scrollUpAtElement", rango_target)</p><p>rule: tiny up &lt;user.rango_target&gt; , imp:user.rango_command_with_target("scrollUpAtElement", rango_target, 0.2)
		</p><p>rule: downer &lt;user.rango_target&gt; , imp:user.rango_command_with_target("scrollDownAtElement", rango_target)</p><p>rule: tiny down &lt;user.rango_target&gt; , imp:user.rango_command_with_target("scrollDownAtElement", rango_target, 0.2)
		</p><p>rule: scroll left &lt;user.rango_target&gt; , imp:user.rango_command_with_target("scrollLeftAtElement", rango_target)</p><p>rule: tiny left &lt;user.rango_target&gt; , imp:user.rango_command_with_target("scrollLeftAtElement", rango_target, 0.1)
		</p><p>rule: scroll right &lt;user.rango_target&gt; , imp:user.rango_command_with_target("scrollRightAtElement", rango_target)</p><p>rule: tiny right &lt;user.rango_target&gt; , imp:user.rango_command_with_target("scrollRightAtElement", rango_target, 0.1)
		
		# Repeat previous scroll</p><p>rule: up again , imp:user.rango_command_without_target("scrollUpAtElement")</p><p>rule: down again , imp:user.rango_command_without_target("scrollDownAtElement")</p><p>rule: left again , imp:user.rango_command_without_target("scrollLeftAtElement")</p><p>rule: right again , imp:user.rango_command_without_target("scrollRightAtElement")</p><p>rule: crown &lt;user.rango_target&gt; , imp:user.rango_command_with_target("scrollElementToTop", rango_target)</p><p>rule: bottom &lt;user.rango_target&gt; , imp:user.rango_command_with_target("scrollElementToBottom", rango_target)</p><p>rule: center &lt;user.rango_target&gt; , imp:user.rango_command_with_target("scrollElementToCenter", rango_target)
		
		# Custom scroll positions</p><p>rule: scroll save &lt;user.word&gt; , imp:user.rango_command_without_target("storeScrollPosition", word)</p><p>rule: scroll to &lt;user.word&gt; , imp:user.rango_command_without_target("scrollToPosition", word)
		
		# Copy target information</p><p>rule: copy [link] &lt;user.rango_target&gt; , imp:user.rango_command_with_target("copyLink", rango_target)</p><p>rule: copy mark &lt;user.rango_target&gt; , imp:user.rango_command_with_target("copyMarkdownLink", rango_target)</p><p>rule: copy text &lt;user.rango_target&gt; , imp:user.rango_command_with_target("copyElementTextContent", rango_target)
		
		# Paste</p><p>rule: paste to &lt;user.rango_target&gt; , imp:user.rango_insert_text_to_input(clip.text(), rango_target, 0)
		
		# Insert text to field</p><p>rule: insert &lt;user.text&gt; to &lt;user.rango_target&gt; , imp:user.rango_insert_text_to_input(text, rango_target, 0)</p><p>rule: enter &lt;user.text&gt; to &lt;user.rango_target&gt; , imp:user.rango_insert_text_to_input(text, rango_target, 1)
		
		# Cursor position</p><p>rule: pre &lt;user.rango_target&gt; , imp:user.rango_command_with_target("setSelectionBefore", rango_target)</p><p>rule: post &lt;user.rango_target&gt; , imp:user.rango_command_with_target("setSelectionAfter", rango_target)
		
		# Clear field</p><p>rule: change &lt;user.rango_target&gt; , imp:user.rango_clear_input(rango_target)
		
		# Copy current url information</p><p>rule: copy page {user.rango_page_location_property} , imp:user.rango_command_without_target("copyLocationProperty", rango_page_location_property)</p><p>rule: copy mark address , imp:user.rango_command_without_target("copyCurrentTabMarkdownUrl")
		
		# Modify hints appearance</p><p>rule: hint bigger , imp:user.rango_command_without_target("increaseHintSize")</p><p>rule: hint smaller , imp:user.rango_command_without_target("decreaseHintSize")</p><p>rule: hint exclude singles , imp:user.rango_command_without_target("excludeSingleLetterHints")</p><p>rule: hint include singles , imp:user.rango_command_without_target("includeSingleLetterHints")</p><p>rule: hint extra , imp:user.rango_command_without_target("displayExtraHints")</p><p>rule: hint more , imp:user.rango_command_without_target("displayExcludedHints")</p><p>rule: hint less , imp:user.rango_command_without_target("displayLessHints")</p><p>rule: include &lt;user.rango_target&gt; , imp:user.rango_command_with_target("includeExtraSelectors", rango_target)</p><p>rule: exclude &lt;user.rango_target&gt; , imp:user.rango_command_with_target("excludeExtraSelectors", rango_target)</p><p>rule: exclude all , imp:user.rango_command_without_target("excludeAllHints")</p><p>rule: some more , imp:user.rango_command_without_target("includeOrExcludeMoreSelectors")</p><p>rule: some less , imp:user.rango_command_without_target("includeOrExcludeLessSelectors")</p><p>rule: custom hints save , imp:user.rango_command_without_target("confirmSelectorsCustomization")</p><p>rule: custom hints reset , imp:user.rango_command_without_target("resetCustomSelectors")</p><p>rule: hints refresh , imp:user.rango_command_without_target("refreshHints")</p><p>rule: hints (toggle | switch) , imp:user.rango_command_without_target("toggleHints")</p><p>rule: hints on [{user.rango_hints_toggle_levels}] , imp:user.rango_command_without_target("enableHints", rango_hints_toggle_levels or "global")</p><p>rule: hints off [{user.rango_hints_toggle_levels}] , imp:user.rango_command_without_target("disableHints", rango_hints_toggle_levels or "global")</p><p>rule: hints reset {user.rango_hints_toggle_levels} , imp:user.rango_command_without_target("resetToggleLevel", rango_hints_toggle_levels)</p><p>rule: toggle show , imp:user.rango_command_without_target("displayTogglesStatus")
		
		# Toggle tab markers</p><p>rule: markers (toggle | switch) , imp:user.rango_command_without_target("toggleTabMarkers")</p><p>rule: keyboard (toggle | switch) , imp:user.rango_command_without_target("toggleKeyboardClicking")</p><p>rule: address in title on , imp:user.rango_command_without_target("enableUrlInTitle")</p><p>rule: address in title off , imp:user.rango_command_without_target("disableUrlInTitle")</p><p>rule: rango settings , imp:user.rango_command_without_target("openSettingsPage")</p><p>rule: rango open {user.rango_page} , imp:user.rango_command_without_target("openPageInNewTab", rango_page)</p><p>rule: mark &lt;user.rango_target&gt; as &lt;user.word&gt; , imp:user.rango_command_with_target("saveReference", rango_target, word)</p><p>rule: mark show , imp:user.rango_command_without_target("showReferences")</p><p>rule: mark clear &lt;user.word&gt; , imp:user.rango_command_without_target("removeReference", word)</p><p>rule: click mark &lt;user.word&gt; , imp:user.rango_run_action_on_reference("clickElement", word)</p><p>rule: focus mark &lt;user.word&gt; , imp:user.rango_run_action_on_reference("focusElement", word)</p><p>rule: hover mark &lt;user.word&gt; , imp:user.rango_run_action_on_reference("hoverElement", word)</p><p>rule: rango explicit , imp:user.rango_force_explicit_clicking()</p><p>rule: rango direct , imp:user.rango_force_direct_clicking()</p><p style="page-break-after: always;">&nbsp;</p><h2>talon helpers</h2><p>rule: click rango mark &lt;user.word&gt; , imp:"user.rango_run_action_on_reference(\"clickElement\", \"{word}\")"</p><p>rule: focus rango mark &lt;user.word&gt; , imp:"user.rango_run_action_on_reference(\"focusElement\", \"{word}\")"</p><p>rule: hover rango mark &lt;user.word&gt; , imp:"user.rango_run_action_on_reference(\"hoverElement\", \"{word}\")"</p><h2>chrome</h2><p>rule: profile switch , imp:user.chrome_mod("shift-m")</p><p>rule: tab search , imp:user.chrome_mod("shift-a")</p><p>rule: tab search &lt;user.text&gt; , imp:user.chrome_mod("shift-a")
		sleep(200ms)
		insert("{text}")
		key(down)</p><h2>discord</h2><p>rule: {user.discord_destination} [&lt;user.text&gt;] , imp:user.discord_quick_switcher(user.discord_destination, user.text or "")</p><p>rule: switcher , imp:user.discord_quick_switcher("", "")</p><p>rule: [channel] mentions last , imp:user.discord_mentions_last()</p><p>rule: [channel] mentions next , imp:user.discord_mentions_next()</p><p>rule: oldest unread , imp:user.discord_oldest_unread()</p><p>rule: current call , imp:user.discord_go_current_call()</p><p>rule: toggle pins , imp:user.discord_toggle_pins()</p><p>rule: toggle inbox , imp:user.discord_toggle_inbox()</p><p>rule: toggle (members | member list) , imp:user.discord_toggle_members()</p><p>rule: toggle (dee ems | dims) , imp:user.discord_toggle_dms()</p><p>rule: pick emoji , imp:user.discord_emoji_picker()</p><p>rule: pick (jif | gif | gift) , imp:user.discord_gif_picker()</p><p>rule: pick sticker , imp:user.discord_sticker_picker()</p><p>rule: mark inbox channel read , imp:user.discord_mark_inbox_read()</p><p>rule: [toggle] (mute | unmute) , imp:user.discord_mute()</p><p>rule: (mute | unmute) and sleep , imp:user.discord_mute()
		speech.disable()</p><p>rule: [toggle] (deafen | undeafen) , imp:user.discord_deafen()</p><p>rule: answer call , imp:user.discord_answer_call()</p><p>rule: decline call , imp:user.discord_decline_call()</p><p style="page-break-after: always;">&nbsp;</p><h2>finder</h2><p>rule: preferences , imp:key(cmd-,)</p><p>rule: options , imp:key(cmd-j)</p><p>rule: search , imp:key(cmd-alt-f)</p><p>rule: sort by none , imp:key(ctrl-alt-cmd-0)</p><p>rule: sort by name , imp:key(ctrl-alt-cmd-1)</p><p>rule: sort by kind , imp:key(ctrl-alt-cmd-2)</p><p>rule: sort by date opened , imp:key(ctrl-alt-cmd-3)</p><p>rule: sort by date added , imp:key(ctrl-alt-cmd-4)</p><p>rule: sort by date modified , imp:key(ctrl-alt-cmd-5)</p><p>rule: sort by size , imp:key(ctrl-alt-cmd-6)</p><p>rule: icon view , imp:key(cmd-1)</p><p>rule: column view , imp:key(cmd-3)</p><p>rule: list view , imp:key(cmd-2)</p><p>rule: gallery view , imp:key(cmd-4)</p><p>rule: copy path , imp:key(alt-cmd-c)</p><p>rule: trash it , imp:key(cmd-backspace)</p><p>rule: hide [finder] , imp:key(cmd-h)</p><p>rule: hide others , imp:app.window_hide_others()</p><h2>firefox</h2><p>rule: tab search , imp:browser.focus_address()
		insert("% ")</p><p>rule: tab search &lt;user.text&gt; , imp:browser.focus_address()
		insert("% {text}")
		key(down)
		</p><p>rule: (sidebar | panel) bookmarks , imp:user.firefox_bookmarks_sidebar()</p><p>rule: (sidebar | panel) history , imp:user.firefox_history_sidebar()</p><p style="page-break-after: always;">&nbsp;</p><h2>git</h2><p>rule: git {user.git_command} [&lt;user.git_arguments&gt;] , imp:args = git_arguments or ""
		"git {git_command}{args} "</p><p>rule: git commit [&lt;user.git_arguments&gt;] message [&lt;user.prose&gt;] , imp:args = git_arguments or ""
		message = prose or ""
		user.insert_between('git commit{args} --message "{message}', '"')</p><p>rule: git stash [push] [&lt;user.git_arguments&gt;] message [&lt;user.prose&gt;] , imp:args = git_arguments or ""
		message = prose or ""
		user.insert_between('git stash push{args} --message "{message}', '"')
		
		# Optimistic execution for frequently used commands that are harmless (don't
		# change repository or index state).</p><p>rule: git status , imp:"git status\n"</p><p>rule: git add patch , imp:"git add --patch\n"</p><p>rule: git show head , imp:"git show HEAD\n"</p><p>rule: git diff , imp:"git diff\n"</p><p>rule: git diff (cached | cashed) , imp:"git diff --cached\n"</p><p>rule: git clone clipboard , imp:insert("git clone ")
		edit.paste()
		key(enter)</p><p>rule: git diff highlighted , imp:edit.copy()
		insert("git diff ")
		edit.paste()
		key(enter)</p><p>rule: git diff clipboard , imp:insert("git diff ")
		edit.paste()
		key(enter)</p><p>rule: git add highlighted , imp:edit.copy()
		insert("git add ")
		edit.paste()
		key(enter)</p><p>rule: git add clipboard , imp:insert("git add ")
		edit.paste()
		key(enter)</p><p>rule: git commit highlighted , imp:edit.copy()
		insert("git add ")
		edit.paste()
		insert("\ngit commit\n")</p><h2>git add patch</h2><p>rule: yank , imp:key(y)
		key(enter)</p><p>rule: near , imp:key(n)
		key(enter)</p><p>rule: quench , imp:key(q)
		key(enter)</p><p>rule: drum , imp:key(d)
		key(enter)</p><p>rule: air , imp:key(a)
		key(enter)</p><h2>github web</h2><p>rule: focus search , imp:key(s)</p><p>rule: go to notifications , imp:insert("gn")</p><p>rule: go to dashboard , imp:insert("gd")</p><p>rule: (keyboard shortcuts show | show keyboard shortcuts) , imp:key(?)</p><p>rule: (selection move down | move selection down) , imp:key(j)</p><p>rule: (selection move up | move selection up) , imp:key(k)</p><p>rule: (selection toggle | toggle selection) , imp:key(x)</p><p>rule: (selection open | open selection) , imp:key(o)</p><p>rule: go to code , imp:insert("gc")</p><p>rule: go to issues , imp:insert("gi")</p><p>rule: go to pull requests , imp:insert("gp")</p><p>rule: go to wiki , imp:insert("gw")</p><p>rule: go to actions , imp:insert("ga")</p><p>rule: go to projects , imp:insert("gb")</p><p>rule: go to discussions , imp:insert("gg")</p><p>rule: [web] editor open , imp:key(.)</p><p>rule: (file find | find file) , imp:key(t)</p><p>rule: jump to line , imp:key(l)</p><p>rule: ((branch | tag) switch | switch (branch | tag)) , imp:key(w)</p><p>rule: (url expand | expand url) , imp:key(y)</p><p>rule: (show | hide) comments , imp:key(i)</p><p>rule: blame view open , imp:key(b)</p><p>rule: (show | hide) annotations , imp:key(a)</p><p>rule: (issue create | create [an] issue) , imp:key(c)</p><p>rule: search (issues | [pull] requests) , imp:key(/)</p><p>rule: (filter by | edit) labels , imp:key(l)</p><p>rule: (filter by | edit) milestones , imp:key(m)</p><p>rule: (filter by | edit) assignee , imp:key(a)</p><p>rule: reply , imp:key(r)</p><p>rule: (comment submit | submit comment) , imp:key(ctrl-enter)</p><p>rule: (comment preview | preview comment) , imp:key(ctrl-shift-p)</p><p>rule: git hub full screen , imp:key(ctrl-shift-l)</p><p>rule: (form close | close form) , imp:key(escape)</p><p>rule: parent commit , imp:key(p)</p><p>rule: other parent commit , imp:key(o)</p><p>rule: mark as read , imp:key(y)</p><p>rule: (thread mute | mute thread) , imp:key(shift-m)</p><p>rule: (issue open | open issue) , imp:key(o)</p><p>rule: (issue create | create issue) , imp:key(c)</p><p>rule: reviewer request , imp:key(q)</p><p>rule: milestone set , imp:key(m)</p><p>rule: assignee set , imp:key(a)</p><p>rule: label set , imp:key(l)</p><p>rule: go to workflow , imp:insert("gf")</p><p>rule: timestamps toggle , imp:key(shift-t)</p><p>rule: fullscreen toggle , imp:key(shift-f)</p><p style="page-break-after: always;">&nbsp;</p><h2>i3wm</h2><p>rule: port &lt;number_small&gt; , imp:user.i3wm_switch_to_workspace(number_small)</p><p>rule: (port flip | flipper) , imp:user.i3wm_switch_to_workspace("back_and_forth")</p><p>rule: port right , imp:user.i3wm_switch_to_workspace("next")</p><p>rule: port left , imp:user.i3wm_switch_to_workspace("prev")</p><p>rule: (win | window) left , imp:user.i3wm_focus("left")</p><p>rule: (win | window) right , imp:user.i3wm_focus("right")</p><p>rule: (win | window) up , imp:user.i3wm_focus("up")</p><p>rule: (win | window) down , imp:user.i3wm_focus("down")</p><p>rule: (win | window) kill , imp:app.window_close()</p><p>rule: (win | window) stacking , imp:user.i3wm_layout("stacking")</p><p>rule: (win | window) default , imp:user.i3wm_layout()</p><p>rule: (win | window) tabbed , imp:user.i3wm_layout("tabbed")</p><p>rule: reload i three config , imp:user.i3wm_reload()</p><p>rule: restart i three , imp:user.i3wm_restart()</p><p>rule: (full screen | scuba) , imp:user.i3wm_fullscreen()</p><p>rule: toggle floating , imp:user.i3wm_float()</p><p>rule: focus floating , imp:user.i3wm_focus("mode_toggle")</p><p>rule: center window , imp:user.i3wm_move_position("center")</p><p>rule: resize mode , imp:user.i3wm_mode("resize")</p><p>rule: focus parent , imp:user.i3wm_focus("parent")</p><p>rule: focus child , imp:user.i3wm_focus("child")</p><p>rule: grow window , imp:user.i3wm_mode("resize")
		key(right:10)
		key(down:10)
		# escape resize mode
		key(escape)
		# center window
		sleep(200ms)
		user.i3wm_move_position("center")
		
		# resize helpers</p><p>rule: shrink window , imp:user.i3wm_mode("resize")
		key(left:10)
		key(up:10)
		# escape resize mode
		key(escape)
		# center window
		sleep(200ms)
		user.i3wm_move_position("center")
		</p><p>rule: horizontal (shell | terminal) , imp:user.i3wm_split("h")
		user.i3wm_shell()
		</p><p>rule: vertical (shell | terminal) , imp:user.i3wm_split("v")
		user.i3wm_shell()
		
		# XXX - just replace with shuffle eventually?
		# XXX - like also need to match the generic talon commands</p><p>rule: (shuffle | move (win | window) [to] port) &lt;number_small&gt; , imp:user.i3wm_move_to_workspace(number_small)</p><p>rule: (shuffle | move (win | window) [to] last port) , imp:user.i3wm_move_to_workspace("back_and_forth")</p><p>rule: (shuffle | move) flipper , imp:user.i3wm_move_to_workspace("back_and_forth")</p><p>rule: (shuffle | move (win | window) left) , imp:user.i3wm_move("left")</p><p>rule: (shuffle | move (win | window) right) , imp:user.i3wm_move("right")</p><p>rule: (shuffle | move (win | window) up) , imp:user.i3wm_move("up")</p><p>rule: (shuffle | move (win | window) down) , imp:user.i3wm_move("down")</p><p>rule: (win | window) horizontal , imp:user.i3wm_split("h")</p><p>rule: (win | window) vertical , imp:user.i3wm_split("v")</p><p>rule: make scratch , imp:user.i3wm_move("scratchpad")</p><p>rule: [(show | hide)] scratch , imp:user.i3wm_show_scratchpad()</p><p>rule: next scratch , imp:user.i3wm_show_scratchpad()
		user.i3wm_show_scratchpad()
		
		# these rely on the user settings for the mod key. see i3wm.py Actions class</p><p>rule: launch , imp:user.i3wm_launch()</p><p>rule: launch &lt;user.text&gt; , imp:user.i3wm_launch()
		sleep(100ms)
		insert("{text}")</p><p>rule: lock screen , imp:user.i3wm_lock()</p><p>rule: (launch shell | koopa) , imp:user.i3wm_shell()</p><p>rule: new scratch (shell | window) , imp:user.i3wm_shell()
		sleep(200ms)
		user.i3wm_move("scratchpad")
		user.i3wm_show_scratchpad()
		</p><p>rule: murder , imp:user.deprecate_command("2023-02-04", "murder", "win kill")
		app.window_close()</p><p style="page-break-after: always;">&nbsp;</p><h2>jetbrains</h2><p>rule: complete , imp:user.idea("action CodeCompletion")</p><p>rule: perfect , imp:user.idea("action CodeCompletion,action CodeCompletion")</p><p>rule: smart , imp:user.idea("action SmartTypeCompletion")</p><p>rule: (done | finish) , imp:user.idea("action EditorCompleteStatement")</p><p>rule: grab &lt;number&gt; , imp:user.idea_grab(number)</p><p>rule: (action | please) , imp:user.idea("action GotoAction")</p><p>rule: (action | please) &lt;user.text&gt; , imp:user.idea("action GotoAction")
		insert(text)
		# Refactoring</p><p>rule: refactor , imp:user.idea("action Refactorings.QuickListPopupAction")</p><p>rule: refactor &lt;user.text&gt; , imp:user.idea("action Refactorings.QuickListPopupAction")
		insert(text)</p><p>rule: extract variable , imp:user.idea("action IntroduceVariable")</p><p>rule: extract field , imp:user.idea("action IntroduceField")</p><p>rule: extract constant , imp:user.idea("action IntroduceConstant")</p><p>rule: extract parameter , imp:user.idea("action IntroduceParameter")</p><p>rule: extract interface , imp:user.idea("action ExtractInterface")</p><p>rule: extract method , imp:user.idea("action ExtractMethod")</p><p>rule: refactor in line , imp:user.idea("action Inline")</p><p>rule: refactor move , imp:user.idea("action Move")</p><p>rule: refactor rename , imp:user.idea("action RenameElement")</p><p>rule: rename file , imp:user.idea("action RenameFile")</p><p>rule: fix (format | formatting) , imp:user.idea("action ReformatCode")</p><p>rule: fix imports , imp:user.idea("action OptimizeImports")</p><p>rule: (go declaration | follow) , imp:user.idea("action GotoDeclaration")</p><p>rule: go implementation , imp:user.idea("action GotoImplementation")</p><p>rule: go usage , imp:user.idea("action FindUsages")</p><p>rule: go type , imp:user.idea("action GotoTypeDeclaration")</p><p>rule: go test , imp:user.idea("action GotoTest")</p><p>rule: go back , imp:user.idea("action Back")</p><p>rule: go forward , imp:user.idea("action Forward")</p><p>rule: find (everywhere | all) , imp:user.idea("action SearchEverywhere")</p><p>rule: find (everywhere | all) &lt;user.text&gt; [over] , imp:user.idea("action SearchEverywhere")
		sleep(500ms)
		insert(text)</p><p>rule: (search | find) class , imp:user.idea("action GotoClass")</p><p>rule: (search | find) file , imp:user.idea("action GotoFile")</p><p>rule: (search | find) path , imp:user.idea("action FindInPath")</p><p>rule: (search | find) symbol , imp:user.idea("action GotoSymbol")</p><p>rule: (search | find) symbol &lt;user.text&gt; , imp:user.idea("action GotoSymbol")
		insert(text)
		key("enter")</p><p>rule: recent , imp:user.idea("action RecentFiles")</p><p>rule: surround [this] with &lt;user.text&gt; [over] , imp:idea("action SurroundWith")
		sleep(500ms)
		insert(text)
		# Making these longer to reduce collisions with real code dictation.</p><p>rule: insert generated &lt;user.text&gt; [over] , imp:user.idea("action Generate")
		sleep(500ms)
		insert(text)</p><p>rule: insert template &lt;user.text&gt; [over] , imp:idea("action InsertLiveTemplate")
		sleep(500ms)
		insert(text)</p><p>rule: create (template | snippet) , imp:user.idea("action SaveAsTemplate")</p><p>rule: toggle recording , imp:user.idea("action StartStopMacroRecording")</p><p>rule: change (recording | recordings) , imp:user.idea("action EditMacros")</p><p>rule: play recording , imp:user.idea("action PlaybackLastMacro")</p><p>rule: play recording &lt;user.text&gt; [over] , imp:idea("action PlaySavedMacrosAction")
		insert(text)
		sleep(500ms)
		Key("enter")
		# Marks</p><p>rule: go mark , imp:user.idea("action ShowBookmarks")</p><p>rule: toggle mark , imp:user.idea("action ToggleBookmark")</p><p>rule: go next mark , imp:user.idea("action GotoNextBookmark")</p><p>rule: go last mark , imp:user.idea("action GotoPreviousBookmark")</p><p>rule: toggle mark &lt;number&gt; , imp:user.idea("action ToggleBookmark{number}")</p><p>rule: go mark &lt;number&gt; , imp:user.idea("action GotoBookmark{number}")</p><p>rule: expand deep , imp:user.idea("action ExpandRegionRecursively")</p><p>rule: expand all , imp:user.idea("action ExpandAllRegions")</p><p>rule: collapse deep , imp:user.idea("action CollapseRegionRecursively")</p><p>rule: collapse all , imp:user.idea("action CollapseAllRegions")</p><p>rule: go next (method | function) , imp:user.idea("action MethodDown")</p><p>rule: go last (method | function) , imp:user.idea("action MethodUp")</p><p>rule: clippings , imp:user.idea("action PasteMultiple")</p><p>rule: copy path , imp:user.idea("action CopyPaths")</p><p>rule: copy reference , imp:user.idea("action CopyReference")</p><p>rule: copy pretty , imp:user.idea("action CopyAsRichText")</p><p>rule: create sibling , imp:user.idea("action NewElementSamePlace")</p><p>rule: create sibling &lt;user.text&gt; [over] , imp:user.idea("action NewElementSamePlace")
		sleep(500ms)
		insert(text)</p><p>rule: create file , imp:user.idea("action NewElement")</p><p>rule: create file &lt;user.text&gt; [over] , imp:user.idea("action NewElement")
		sleep(500ms)
		insert(text)
		# Task Management</p><p>rule: go task , imp:user.idea("action tasks.goto")</p><p>rule: go browser task , imp:user.idea("action tasks.open.in.browser")</p><p>rule: switch task , imp:user.idea("action tasks.switch")</p><p>rule: clear task , imp:user.idea("action tasks.close")</p><p>rule: configure servers , imp:user.idea("action tasks.configure.servers")</p><p>rule: git pull , imp:user.idea("action Vcs.UpdateProject")</p><p>rule: git commit , imp:user.idea("action CheckinProject")</p><p>rule: git push , imp:user.idea("action CheckinProject")</p><p>rule: git log , imp:user.idea("action Vcs.ShowTabbedFileHistory")</p><p>rule: git browse , imp:user.idea("action Github.Open.In.Browser")</p><p>rule: git (gets | gist) , imp:user.idea("action Github.Create.Gist")</p><p>rule: git (pull request | request) , imp:user.idea("action Github.Create.Pull.Request")</p><p>rule: git (view | show | list) (requests | request) , imp:user.idea("action Github.View.Pull.Request")</p><p>rule: git (annotate | blame) , imp:user.idea("action Annotate")</p><p>rule: git menu , imp:user.idea("action Vcs.QuickListPopupAction")</p><p>rule: toggle project , imp:user.idea("action ActivateProjectToolWindow")</p><p>rule: toggle find , imp:user.idea("action ActivateFindToolWindow")</p><p>rule: toggle run , imp:user.idea("action ActivateRunToolWindow")</p><p>rule: toggle debug , imp:user.idea("action ActivateDebugToolWindow")</p><p>rule: toggle events , imp:user.idea("action ActivateEventLogToolWindow")</p><p>rule: toggle terminal , imp:user.idea("action ActivateTerminalToolWindow")</p><p>rule: toggle git , imp:user.idea("action ActivateVersionControlToolWindow")</p><p>rule: toggle structure , imp:user.idea("action ActivateStructureToolWindow")</p><p>rule: toggle database , imp:user.idea("action ActivateDatabaseToolWindow")</p><p>rule: toggle database changes , imp:user.idea("action ActivateDatabaseChangesToolWindow")</p><p>rule: toggle make , imp:user.idea("action ActivatemakeToolWindow")</p><p>rule: toggle to do , imp:user.idea("action ActivateTODOToolWindow")</p><p>rule: toggle docker , imp:user.idea("action ActivateDockerToolWindow")</p><p>rule: toggle favorites , imp:user.idea("action ActivateFavoritesToolWindow")</p><p>rule: toggle last , imp:user.idea("action JumpToLastWindow")</p><p>rule: toggle pinned , imp:user.idea("action TogglePinnedMode")</p><p>rule: toggle docked , imp:user.idea("action ToggleDockMode")</p><p>rule: toggle floating , imp:user.idea("action ToggleFloatingMode")</p><p>rule: toggle windowed , imp:user.idea("action ToggleWindowedMode")</p><p>rule: toggle split , imp:user.idea("action ToggleSideMode")</p><p>rule: toggle tool buttons , imp:user.idea("action ViewToolButtons")</p><p>rule: toggle toolbar , imp:user.idea("action ViewToolBar")</p><p>rule: toggle status [bar] , imp:user.idea("action ViewStatusBar")</p><p>rule: toggle navigation [bar] , imp:user.idea("action ViewNavigationBar")</p><p>rule: toggle power save , imp:user.idea("action TogglePowerSave")</p><p>rule: toggle whitespace , imp:user.idea("action EditorToggleShowWhitespaces")</p><p>rule: toggle indents , imp:user.idea("action EditorToggleShowIndentLines")</p><p>rule: toggle line numbers , imp:user.idea("action EditorToggleShowLineNumbers")</p><p>rule: toggle (bread crumbs | breadcrumbs) , imp:user.idea("action EditorToggleShowBreadcrumbs")</p><p>rule: toggle gutter icons , imp:user.idea("action EditorToggleShowGutterIcons")</p><p>rule: toggle wrap , imp:user.idea("action EditorToggleUseSoftWraps")</p><p>rule: toggle parameters , imp:user.idea("action ToggleInlineHintsAction")</p><p>rule: toggle fullscreen , imp:user.idea("action ToggleFullScreen")</p><p>rule: toggle distraction [free mode] , imp:user.idea("action ToggleDistractionFreeMode")</p><p>rule: toggle presentation [mode] , imp:user.idea("action TogglePresentationMode")</p><p>rule: toggle comment , imp:code.toggle_comment()</p><p>rule: change scheme , imp:user.idea("action QuickChangeScheme")</p><p>rule: (toggle | pop) (doc | documentation) , imp:user.idea("action QuickJavaDoc")</p><p>rule: (pop deaf | toggle definition) , imp:user.idea("action QuickImplementations")</p><p>rule: pop type , imp:user.idea("action ExpressionTypeInfo")</p><p>rule: pop parameters , imp:user.idea("action ParameterInfo")</p><p>rule: go breakpoints , imp:user.idea("action ViewBreakpoints")</p><p>rule: toggle [line] breakpoint , imp:user.idea("action ToggleLineBreakpoint")</p><p>rule: toggle method breakpoint , imp:user.idea("action ToggleMethodBreakpoint")</p><p>rule: run menu , imp:user.idea("action ChooseRunConfiguration")</p><p>rule: run test , imp:user.idea("action RunClass")</p><p>rule: run test again , imp:user.idea("action Rerun")</p><p>rule: debug test , imp:user.idea("action DebugClass")</p><p>rule: step over , imp:user.idea("action StepOver")</p><p>rule: step into , imp:user.idea("action StepInto")</p><p>rule: step smart , imp:user.idea("action SmartStepInto")</p><p>rule: step to line , imp:user.idea("action RunToCursor")</p><p>rule: continue , imp:user.idea("action Resume")</p><p>rule: (grow | shrink) window right , imp:user.idea("action ResizeToolWindowRight")</p><p>rule: (grow | shrink) window left , imp:user.idea("action ResizeToolWindowLeft")</p><p>rule: (grow | shrink) window up , imp:user.idea("action ResizeToolWindowUp")</p><p>rule: (grow | shrink) window down , imp:user.idea("action ResizeToolWindowDown")</p><p>rule: go next (error | air) , imp:user.idea("action GotoNextError")</p><p>rule: go last (error | air) , imp:user.idea("action GotoPreviousError")</p><p>rule: fix next (error | air) , imp:user.idea("action GotoNextError")
		user.idea("action ShowIntentionActions")</p><p>rule: fix last (error | air) , imp:user.idea("action GotoPreviousError")
		user.idea("action ShowIntentionActions")
		# Special Selects</p><p>rule: select less , imp:user.idea("action EditorUnSelectWord")</p><p>rule: select (more | this) , imp:user.idea("action EditorSelectWord")</p><p>rule: expand &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		user.idea("action ExpandRegion")</p><p>rule: collapse &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		user.idea("action CollapseRegion")</p><p>rule: paste &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		user.idea("action EditorPaste")</p><p>rule: refactor &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		user.idea("action Refactorings.QuickListPopupAction")</p><p>rule: clone &lt;number&gt; , imp:user.line_clone(number)</p><p>rule: clear last &lt;user.text&gt; [over] , imp:user.idea("find prev {text}, action EditorBackSpace")</p><p>rule: clear next &lt;user.text&gt; [over] , imp:user.idea("find next {text}, action EditorBackSpace")</p><p>rule: comment last &lt;user.text&gt; [over] , imp:user.idea("find prev {text}, action CommentByLineComment")</p><p>rule: comment next &lt;user.text&gt; [over] , imp:user.idea("find next {text}, action CommentByLineComment")</p><p>rule: go last &lt;user.text&gt; [over] , imp:user.idea("find prev {text}, action EditorRight")</p><p>rule: go next &lt;user.text&gt; [over] , imp:user.idea("find next {text}, action EditorRight")</p><p>rule: paste last &lt;user.text&gt; [over] , imp:user.idea("find prev {text}, action EditorRight, action EditorPaste")</p><p>rule: paste next &lt;user.text&gt; [over] , imp:user.idea("find next {text}, action EditorRight, action EditorPaste")</p><p>rule: refactor last &lt;user.text&gt; [over] , imp:user.idea("find prev {text}, action Refactorings.QuickListPopupAction")</p><p>rule: refactor next &lt;user.text&gt; [over] , imp:user.idea("find next {text}, action Refactorings.QuickListPopupAction")</p><p>rule: replace last &lt;user.text&gt; [over] , imp:user.idea("find prev {text}, action EditorPaste")</p><p>rule: replace next &lt;user.text&gt; [over] , imp:user.idea("find next {text}, action EditorPaste")</p><p>rule: select last &lt;user.text&gt; [over] , imp:user.idea("find prev {text}")</p><p>rule: select next &lt;user.text&gt; [over] , imp:user.idea("find next {text}")</p><p>rule: select camel left , imp:user.extend_camel_left()</p><p>rule: select camel right , imp:user.extend_camel_right()</p><p>rule: go camel left , imp:user.camel_left()</p><p>rule: go camel right , imp:user.camel_right()</p><p>rule: blacken , imp:user.idea("action BLACKReformatCode")</p><p style="page-break-after: always;">&nbsp;</p><h2>kubectl</h2><p>rule: cube [control] , imp:"kubectl "</p><p>rule: cube create , imp:"kubectl create "</p><p>rule: cube expose , imp:"kubectl expose "</p><p>rule: cube run , imp:"kubectl run "</p><p>rule: cube set , imp:"kubectl set "</p><p>rule: cube run container , imp:"kubectl run-container "</p><p>rule: cube explain , imp:"kubectl explain "</p><p>rule: cube get , imp:"kubectl get "</p><p>rule: cube edit , imp:"kubectl edit "</p><p>rule: cube delete , imp:"kubectl delete "</p><p>rule: cube rollout , imp:"kubectl rollout "</p><p>rule: cube rolling update , imp:"kubectl rolling-update "</p><p>rule: cube scale , imp:"kubectl scale "</p><p>rule: cube auto scale , imp:"kubectl autoscale "</p><p>rule: cube certificate , imp:"kubectl certificate "</p><p>rule: cube top , imp:"kubectl top "</p><p>rule: cube drain , imp:"kubectl drain "</p><p>rule: cube taint , imp:"kubectl taint "</p><p>rule: cube (cord | cordon) , imp:"kubectl cordon "</p><p>rule: cube (uncord | uncordon) , imp:"kubectl uncordon "</p><p>rule: cube cluster (info | information) , imp:"kubectl cluster-info "</p><p>rule: cube describe , imp:"kubectl describe "</p><p>rule: cube logs , imp:"kubectl logs "</p><p>rule: cube attach , imp:"kubectl attach "</p><p>rule: cube exec , imp:"kubectl exec "</p><p>rule: cube port forward , imp:"kubectl port-forward "</p><p>rule: cube proxy , imp:"kubectl proxy "</p><p>rule: cube copy , imp:"kubectl cp "</p><p>rule: cube auth , imp:"kubectl auth "</p><p>rule: cube diff , imp:"kubectl diff "</p><p>rule: cube apply , imp:"kubectl apply "</p><p>rule: cube patch , imp:"kubectl patch "</p><p>rule: cube replace , imp:"kubectl replace "</p><p>rule: cube wait , imp:"kubectl wait "</p><p>rule: cube convert , imp:"kubectl convert "</p><p>rule: cube customize , imp:"kubectl kustomize "</p><p>rule: cube label , imp:"kubectl label "</p><p>rule: cube annotate , imp:"kubectl annotate "</p><p>rule: cube completion , imp:"kubectl completion "</p><p>rule: cube (interface | API) , imp:"kubectl api "</p><p>rule: cube interface resources , imp:"kubectl api-resources "</p><p>rule: cube interface versions , imp:"kubectl api-versions "</p><p>rule: cube config , imp:"kubectl config "</p><p>rule: cube help , imp:"kubectl help "</p><p>rule: cube plugin , imp:"kubectl plugin "</p><p>rule: cube version , imp:"kubectl version "</p><p>rule: cube {user.kubectl_action} [{user.kubectl_object}] , imp:insert("kubectl {kubectl_action} ")
		insert(kubectl_object or "")
		</p><p>rule: cube detach , imp:key("ctrl-p")
		key("ctrl-q")</p><p>rule: cube shell , imp:user.insert_between("kubectl exec -it ", " -- /bin/bash")</p><p style="page-break-after: always;">&nbsp;</p><h2>outlook web</h2><p>rule: new message , imp:key(n)</p><p>rule: send [this] message , imp:key(alt-s)</p><p>rule: reply [to] [this] message , imp:key(r)</p><p>rule: reply all [to] [this] message , imp:key(ctrl-shift-r)</p><p>rule: forward [this] message , imp:key(ctrl-shift-f)</p><p>rule: save [draft] , imp:key(ctrl-s)</p><p>rule: discard [draft] , imp:key(esc)</p><p>rule: insert [a] [hyper] link , imp:key(ctrl-k)</p><p>rule: (select | unselect) [this] message , imp:key(ctrl-space)</p><p>rule: select all [messages] , imp:key(ctrl-a)</p><p>rule: clear all [messages] , imp:key(esc)</p><p>rule: select first [message] , imp:key(home)</p><p>rule: select last [message] , imp:key(and)</p><p>rule: open [this] message , imp:key(o)</p><p>rule: open [this] message [in] [a] new window , imp:key(shift-enter)</p><p>rule: close [this] message , imp:key(esc)</p><p>rule: [open] [the] next (item | message) , imp:key(ctrl-.)</p><p>rule: [open] [the] (prev | previous) item , imp:key(ctrl-,)</p><p>rule: next reading [pane] (item | message) , imp:key(.)</p><p>rule: (prev | previous) [pane] (item | message) , imp:key(,)</p><p>rule: (expand | collapse) [conversation] , imp:key(x)</p><p>rule: go [to] mail , imp:key(ctrl-shift-1)</p><p>rule: go [to] calendar , imp:key(ctrl-shift-2)</p><p>rule: go [to] people , imp:key(ctrl-shift-3)</p><p>rule: go [to] to do , imp:key(ctrl-shift-4)</p><p>rule: go [to] inbox , imp:key(g)
		key(i)</p><p>rule: go to drafts , imp:key(g)
		key(d)</p><p>rule: go to sent , imp:key(g)
		key(s)</p><p>rule: search [email] , imp:key(alt-q)</p><p>rule: show help , imp:key(?)</p><p>rule: undo [last] [action] , imp:key(ctrl-z)</p><p>rule: delete [this] [message] , imp:key(delete)</p><p>rule: (perm | permanently) delete [this] [message] , imp:key(shift+delete)</p><p>rule: new folder , imp:key(shift-e)</p><p>rule: mark [this] [(item | message)] as read , imp:key(q)</p><p>rule: mark [this] [(item | message)] as unread , imp:key(u)</p><p>rule: flag [this] [(item | message)] , imp:key(insert)</p><p>rule: archive , imp:key(e)</p><p>rule: mark [this] [message] [as] junk , imp:key(j)</p><p>rule: moved to [a] folder , imp:key(v)</p><p>rule: categorize [this] message , imp:key(c)</p><p style="page-break-after: always;">&nbsp;</p><h2>outlook win</h2><p>rule: archive , imp:key(alt h o 1)</p><p>rule: new e-mail , imp:key(ctrl-n)</p><p>rule: calendar , imp:key(ctrl-2)</p><p>rule: inbox , imp:key(ctrl-1)</p><p>rule: Reply , imp:key(ctrl-r)</p><p>rule: Reply all , imp:key(ctrl-shift-r)</p><p>rule: Forward , imp:key(ctrl-f)</p><p>rule: accept , imp:key(shift-f10 c c enter)</p><h2>slack mac</h2><p>rule: workspace &lt;number&gt; , imp:key("cmd-{number}")</p><p>rule: (slack | lack) [channel] info , imp:key(cmd-shift-i)</p><p>rule: focus (move | next) , imp:key(ctrl-`)</p><p>rule: (section | zone) [next] , imp:key(f6)</p><p>rule: (section | zone) (previous | last) , imp:key(shift-f6)</p><p>rule: (slack | lack) [direct] messages , imp:key(cmd-shift-k)</p><p>rule: (slack | lack) threads , imp:key(cmd-shift-t)</p><p>rule: (slack | lack) (history [next] | back | backward) , imp:key(cmd-[)</p><p>rule: (slack | lack) forward , imp:key(cmd-])</p><p>rule: (element | bit) [next] , imp:key(tab)</p><p>rule: (element | bit) (previous | last) , imp:key(shift-tab)</p><p>rule: (slack | lack) (my stuff | activity) , imp:key(cmd-shift-m)</p><p>rule: (slack | lack) directory , imp:key(cmd-shift-e)</p><p>rule: (slack | lack) (starred [items] | stars) , imp:key(cmd-shift-s)</p><p>rule: (slack | lack) unread [messages] , imp:key(cmd-shift-a)</p><p>rule: (go | undo | toggle) full , imp:key(ctrl-cmd-f)</p><p>rule: grab left , imp:key(shift-up)</p><p>rule: grab right , imp:key(shift-down)</p><p>rule: add line , imp:key(shift-enter)</p><p>rule: (slack | lack) (slap | slaw | slapper) , imp:key(cmd-right shift-enter)</p><p>rule: (slack | lack) (react | reaction) , imp:key(cmd-shift-\)</p><p>rule: (insert command | commandify) , imp:key(cmd-shift-c)</p><p>rule: insert link , imp:key(cmd-shift-u)</p><p>rule: insert code , imp:key(cmd-shift-alt-c)</p><p>rule: (slack | lack) (bull | bullet | bulleted) [list] , imp:key(cmd-shift-8)</p><p>rule: (slack | lack) (number | numbered) [list] , imp:key(cmd-shift-7)</p><p>rule: (slack | lack) (quotes | quotation) , imp:key(cmd-shift-&gt;)</p><p>rule: bold , imp:key(cmd-b)</p><p>rule: (italic | italicize) , imp:key(cmd-i)</p><p>rule: (strike | strikethrough) , imp:key(cmd-shift-x)</p><p>rule: (slack | lack) snippet , imp:key(cmd-shift-enter)</p><p>rule: ([toggle] mute | unmute) , imp:key(m)</p><p>rule: (slack | lack) huddle , imp:key(cmd-shift-h)</p><p>rule: (slack | lack) ([toggle] video) , imp:key(v)</p><p>rule: (slack | lack) invite , imp:key(a)</p><p>rule: (slack | lack) shortcuts , imp:key(cmd-/)</p><p>rule: emote &lt;user.text&gt; , imp:"{text}"</p><p>rule: toggle left sidebar , imp:key(cmd-shift-d)</p><p>rule: toggle right sidebar , imp:key(cmd-.)</p><p>rule: (move | next) focus , imp:app.notify("please use the voice command 'focus next' instead of 'next focus'")
		key(ctrl-`)</p><p>rule: [next] (section | zone) , imp:app.notify("please use the voice command 'section next' instead of 'next section'")
		key(f6)</p><p>rule: (previous | last) (section | zone) , imp:app.notify("please use the voice command 'section last' instead of 'last section'")
		key(shift-f6)</p><p>rule: [next] (element | bit) , imp:app.notify("please use the voice command 'element next' instead of 'next element'")
		key(tab)</p><p>rule: (previous | last) (element | bit) , imp:app.notify("please use the voice command 'element last' instead of 'last element'")
		key(shift-tab)</p><p style="page-break-after: always;">&nbsp;</p><h2>slack win</h2><p>rule: workspace &lt;number&gt; , imp:key("ctrl-{number}")</p><p>rule: (slack | lack) [channel] info , imp:key(ctrl-shift-i)</p><p>rule: focus (move | next) , imp:key(ctrl-`)</p><p>rule: (section | zone) [next] , imp:key(f6)</p><p>rule: (section | zone) (previous | last) , imp:key(shift-f6)</p><p>rule: (slack | lack) [direct] messages , imp:key(ctrl-shift-k)</p><p>rule: (slack | lack) threads , imp:key(ctrl-shift-t)</p><p>rule: (slack | lack) (history [next] | back | backward) , imp:key(alt-left)</p><p>rule: (slack | lack) forward , imp:key(alt-right)</p><p>rule: (element | bit) [next] , imp:key(tab)</p><p>rule: (element | bit) (previous | last) , imp:key(shift-tab)</p><p>rule: (slack | lack) (my stuff | activity) , imp:key(ctrl-shift-m)</p><p>rule: (slack | lack) directory , imp:key(ctrl-shift-e)</p><p>rule: (slack | lack) (starred [items] | stars) , imp:key(ctrl-shift-s)</p><p>rule: (slack | lack) unread [messages] , imp:key(ctrl-shift-a)</p><p>rule: grab left , imp:key(shift-up)</p><p>rule: grab right , imp:key(shift-down)</p><p>rule: add line , imp:key(shift-enter)</p><p>rule: (slack | lack) (react | reaction) , imp:key(ctrl-shift-\)</p><p>rule: (insert command | commandify) , imp:key(ctrl-shift-c)</p><p>rule: insert code , imp:insert("```")</p><p>rule: (slack | lack) (bull | bullet | bulleted) [list] , imp:key(ctrl-shift-8)</p><p>rule: (slack | lack) (number | numbered) [list] , imp:key(ctrl-shift-7)</p><p>rule: (slack | lack) (quotes | quotation) , imp:key(ctrl-shift-9)</p><p>rule: bold , imp:key(ctrl-b)</p><p>rule: (italic | italicize) , imp:key(ctrl-i)</p><p>rule: (strike | strikethrough) , imp:key(ctrl-shift-x)</p><p>rule: (slack | lack) snippet , imp:key(ctrl-shift-enter)</p><p>rule: ([toggle] mute | unmute) , imp:key(m)</p><p>rule: (slack | lack) ([toggle] video) , imp:key(v)</p><p>rule: (slack | lack) invite , imp:key(a)</p><p>rule: (slack | lack) shortcuts , imp:key(ctrl-/)</p><p>rule: emote &lt;user.text&gt; , imp:"{text}"</p><p>rule: toggle left sidebar , imp:key(ctrl-shift-d)</p><p>rule: toggle right sidebar , imp:key(ctrl-.)</p><p>rule: (move | next) focus , imp:app.notify("please use the voice command 'focus next' instead of 'next focus'")
		key(ctrl-`)</p><p>rule: [next] (section | zone) , imp:app.notify("please use the voice command 'section next' instead of 'next section'")
		key(f6)</p><p>rule: (previous | last) (section | zone) , imp:app.notify("please use the voice command 'section last' instead of 'last section'")
		key(shift-f6)</p><p>rule: [next] (element | bit) , imp:app.notify("please use the voice command 'element next' instead of 'next element'")
		key(tab)</p><p>rule: (previous | last) (element | bit) , imp:app.notify("please use the voice command 'element last' instead of 'last element'")
		key(shift-tab)</p><p style="page-break-after: always;">&nbsp;</p><h2>talon repl</h2><p>rule: test last , imp:phrase = user.history_get(1)
		command = "sim('{phrase}')"
		insert(command)
		key(enter)</p><p>rule: test &lt;phrase&gt; , imp:insert("sim('{phrase}')")
		key(enter)</p><p>rule: test numb &lt;number_small&gt; , imp:phrase = user.history_get(number_small)
		command = "sim('{phrase}')"
		#to do: shouldn't this work?
		#user.paste("sim({phrase})")
		insert(command)
		key(enter)
		# requires user.talon_populate_lists tag. do not use with dragon</p><p>rule: debug action {user.talon_actions} , imp:insert("actions.find('{user.talon_actions}')")
		key(enter)
		# requires user.talon_populate_lists tag. do not use with dragon</p><p>rule: debug list {user.talon_lists} , imp:insert("actions.user.talon_pretty_print(registry.lists['{talon_lists}'])")
		key(enter)</p><p>rule: debug tags , imp:insert("actions.user.talon_pretty_print(registry.tags)")
		key(enter)</p><p>rule: debug settings , imp:insert("actions.user.talon_pretty_print(registry.settings)")
		key(enter)</p><p>rule: debug modes , imp:insert("actions.user.talon_pretty_print(scope.get('mode'))")
		key(enter)
		# requires user.talon_populate_lists tag. do not use with dragon</p><p>rule: debug scope {user.talon_scopes} , imp:insert("actions.user.talon_pretty_print(scope.get('{talon_scopes}'))")
		key(enter)</p><p>rule: debug running apps , imp:insert("actions.user.talon_pretty_print(ui.apps(background=False))")
		key(enter)</p><p>rule: debug all windows , imp:insert("actions.user.talon_pretty_print(ui.windows())")
		key(enter)</p><p>rule: debug {user.running} windows , imp:insert("actions.user.talon_debug_app_windows('{running}')")
		key(enter)</p><h2>terraform</h2><p>rule: terraform , imp:"terraform "</p><p>rule: terraform apply , imp:"terraform apply "</p><p>rule: terraform destroy , imp:"terraform destroy "</p><p>rule: terraform format recursive , imp:"terraform fmt -recursive\n"</p><p>rule: terraform format , imp:"terraform fmt\n"</p><p>rule: terraform help , imp:"terraform -help"</p><p>rule: terraform init upgrade , imp:"terraform init -upgrade\n"</p><p>rule: terraform init , imp:"terraform init\n"</p><p>rule: terraform plan , imp:"terraform plan\n"</p><p>rule: terraform state move , imp:"terraform state mv "</p><p>rule: terraform validate , imp:"terraform validate\n"</p><p style="page-break-after: always;">&nbsp;</p><h2>thunderbird</h2><p>rule: go (mails | messages | inbox) , imp:user.tab_jump(1)</p><p>rule: go (calendar | lightning) , imp:user.thunderbird_mod("shift-c")</p><p>rule: go tasks , imp:user.thunderbird_mod("shift-d")</p><p>rule: (open address [book] | address book | open contacts) , imp:user.thunderbird_mod("shift-b")</p><p>rule: dev tools , imp:user.thunderbird_mod("shift-i")</p><h2>thunderbird calendar</h2><p>rule: event new , imp:user.thunderbird_mod("i")</p><p>rule: task new , imp:user.thunderbird_mod("d")</p><p>rule: (task | event) delete , imp:key(delete)</p><p>rule: toggle today , imp:key(f11)</p><p>rule: view &lt;number_small&gt; , imp:user.thunderbird_calendar_view(number_small)</p><p>rule: view day , imp:user.thunderbird_calendar_view(1)</p><p>rule: view week , imp:user.thunderbird_calendar_view(2)</p><p>rule: view multi [week] , imp:user.thunderbird_calendar_view(3)</p><p>rule: view month , imp:user.thunderbird_calendar_view(4)</p><h2>thunderbird composer</h2><p>rule: (draft | mail | message) save , imp:user.thunderbird_mod("s")</p><p>rule: (draft | mail | message) print , imp:user.thunderbird_mod("p")</p><p>rule: (draft | mail | message) send , imp:user.thunderbird_mod("enter")</p><p>rule: toggle contacts , imp:key(f9)</p><p>rule: go (inbox | thunderbird | main) , imp:user.thunderbird_mod("1")</p><p>rule: cite paste , imp:user.thunderbird_mod("shift-o")</p><p>rule: (unformatted | raw) paste , imp:user.thunderbird_mod("shift-v")</p><p>rule: link new , imp:user.thunderbird_mod("k")</p><p>rule: link delete , imp:user.thunderbird_mod("shift-k")</p><p style="page-break-after: always;">&nbsp;</p><h2>thunderbird contacts</h2><p>rule: contact new , imp:user.thunderbird_mod("n")</p><p>rule: contact edit , imp:user.thunderbird_mod("i")</p><p>rule: contact delete , imp:key(delete)</p><p>rule: contact print , imp:user.thunderbird_mod("p")</p><p>rule: contact message , imp:user.thunderbird_mod("m")</p><p>rule: contact up , imp:key(up)</p><p>rule: contact down , imp:key(down)</p><h2>thunderbird inbox</h2><p>rule: (mail | message) open , imp:key(enter)</p><p>rule: (mail | message) (up | last) , imp:key(b)</p><p>rule: (mail | message) (down | next) , imp:key(f)</p><p>rule: unread [mail | message] (up | last) , imp:key(p)</p><p>rule: unread [mail | message] (down | next) , imp:key(n)</p><p>rule: go home , imp:key(alt-home)</p><p>rule: toggle (mail | message) [pane] , imp:key(f8)</p><p>rule: (mail | message) (favorite | unfavorite) , imp:key(s)</p><p>rule: (mail | message) (read | unread) , imp:key(m)</p><p>rule: (mail | message) (watch | unwatch) , imp:key(w)</p><p>rule: (mail | message) (ignore | unignore) , imp:key(k)</p><p>rule: (mail | message) suspend , imp:key(c)</p><p>rule: (mail | message) spam , imp:key(j)</p><p>rule: (mail | message) new , imp:user.thunderbird_mod("n")</p><p>rule: (mail | message) edit , imp:user.thunderbird_mod("e")</p><p>rule: (mail | message) reply sender , imp:user.thunderbird_mod("r")</p><p>rule: (mail | message) reply all , imp:user.thunderbird_mod("shift-r")</p><p>rule: (mail | message) reply list , imp:user.thunderbird_mod("shift-l")</p><p>rule: (mail | message) forward , imp:user.thunderbird_mod("l")</p><p>rule: (mail | message) delete , imp:key(delete)</p><p>rule: (mail | message) archive , imp:key(a)</p><p>rule: (mail | message) save , imp:user.thunderbird_mod("s")</p><p>rule: (mail | message) print , imp:user.thunderbird_mod("p")</p><p style="page-break-after: always;">&nbsp;</p><h2>thunderbird tasks</h2><p>rule: event new , imp:user.thunderbird_mod("i")</p><p>rule: task new , imp:user.thunderbird_mod("d")</p><p>rule: (task | event) delete , imp:key(delete)</p><p>rule: toggle today , imp:key(f11)</p><h2>twitter</h2><p>rule: (show shortcuts | shortcuts help) , imp:key(?)</p><p>rule: next tweet , imp:key(j)</p><p>rule: previous tweet , imp:key(k)</p><p>rule: page down , imp:key(space)</p><p>rule: load new tweet , imp:key(.)</p><p>rule: go home , imp:insert("gh")</p><p>rule: go explore , imp:insert("ge")</p><p>rule: go notifications , imp:insert("gn")</p><p>rule: go mentions , imp:insert("gr")</p><p>rule: go profile , imp:insert("gp")</p><p>rule: go likes , imp:insert("gl")</p><p>rule: go lists , imp:insert("gi")</p><p>rule: go direct messages , imp:insert("gm")</p><p>rule: go settings , imp:insert("gs")</p><p>rule: go book marks , imp:insert("gb")</p><p>rule: go to user , imp:insert("gu")</p><p>rule: display settings , imp:insert("gd")</p><p>rule: new tweet , imp:key(n)</p><p>rule: send tweet , imp:key(ctrl-enter)</p><p>rule: new direct message , imp:key(m)</p><p>rule: search , imp:key(/)</p><p>rule: like message , imp:key(l)</p><p>rule: reply message , imp:key(r)</p><p>rule: re tweet [message] , imp:key(t)</p><p>rule: share tweet , imp:key(s)</p><p>rule: bookmark , imp:key(b)</p><p>rule: mute account , imp:key(urge)</p><p>rule: block account , imp:key(x)</p><p>rule: open details , imp:key(enter)</p><p>rule: expand photo , imp:key(o)</p><p style="page-break-after: always;">&nbsp;</p><h2>vscode</h2><p>rule: window reload , imp:user.vscode("workbench.action.reloadWindow")</p><p>rule: window close , imp:user.vscode("workbench.action.closeWindow")</p><p>rule: please [&lt;user.text&gt;] , imp:user.vscode("workbench.action.showCommands")
		insert(user.text or "")
		
		# Sidebar</p><p>rule: bar explore , imp:user.vscode("workbench.view.explorer")</p><p>rule: bar extensions , imp:user.vscode("workbench.view.extensions")</p><p>rule: bar outline , imp:user.vscode("outline.focus")</p><p>rule: bar run , imp:user.vscode("workbench.view.debug")</p><p>rule: bar search , imp:user.vscode("workbench.view.search")</p><p>rule: bar source , imp:user.vscode("workbench.view.scm")</p><p>rule: bar test , imp:user.vscode("workbench.view.testing.focus")</p><p>rule: bar switch , imp:user.vscode("workbench.action.toggleSidebarVisibility")</p><p>rule: symbol hunt [&lt;user.text&gt;] , imp:user.vscode("workbench.action.gotoSymbol")
		sleep(50ms)
		insert(text or "")
		</p><p>rule: symbol hunt all [&lt;user.text&gt;] , imp:user.vscode("workbench.action.showAllSymbols")
		sleep(50ms)
		insert(text or "")
		
		# Panels</p><p>rule: panel control , imp:user.vscode("workbench.panel.repl.view.focus")</p><p>rule: panel output , imp:user.vscode("workbench.panel.output.focus")</p><p>rule: panel problems , imp:user.vscode("workbench.panel.markers.view.focus")</p><p>rule: panel switch , imp:user.vscode("workbench.action.togglePanel")</p><p>rule: panel terminal , imp:user.vscode("workbench.action.terminal.focus")</p><p>rule: focus editor , imp:user.vscode("workbench.action.focusActiveEditorGroup")</p><p>rule: show settings , imp:user.vscode("workbench.action.openGlobalSettings")</p><p>rule: show settings json , imp:user.vscode("workbench.action.openSettingsJson")</p><p>rule: show settings folder , imp:user.vscode("workbench.action.openFolderSettings")</p><p>rule: show settings folder json , imp:user.vscode("workbench.action.openFolderSettingsFile")</p><p>rule: show settings workspace , imp:user.vscode("workbench.action.openWorkspaceSettings")</p><p>rule: show settings workspace json , imp:user.vscode("workbench.action.openWorkspaceSettingsFile")</p><p>rule: show shortcuts , imp:user.vscode("workbench.action.openGlobalKeybindings")</p><p>rule: show shortcuts json , imp:user.vscode("workbench.action.openGlobalKeybindingsFile")</p><p>rule: show snippets , imp:user.vscode("workbench.action.openSnippets")</p><p>rule: snip (last | previous) , imp:user.vscode("jumpToPrevSnippetPlaceholder")</p><p>rule: snip next , imp:user.vscode("jumpToNextSnippetPlaceholder")</p><p>rule: centered switch , imp:user.vscode("workbench.action.toggleCenteredLayout")</p><p>rule: fullscreen switch , imp:user.vscode("workbench.action.toggleFullScreen")</p><p>rule: theme switch , imp:user.vscode("workbench.action.selectTheme")</p><p>rule: wrap switch , imp:user.vscode("editor.action.toggleWordWrap")</p><p>rule: zen switch , imp:user.vscode("workbench.action.toggleZenMode")</p><p>rule: file hunt [&lt;user.text&gt;] , imp:user.vscode("workbench.action.quickOpen")
		sleep(50ms)
		insert(text or "")</p><p>rule: file hunt (pace | paste) , imp:user.vscode("workbench.action.quickOpen")
		sleep(50ms)
		edit.paste()</p><p>rule: file copy name , imp:user.vscode("fileutils.copyFileName")</p><p>rule: file copy path , imp:user.vscode("copyFilePath")</p><p>rule: file copy local [path] , imp:user.vscode("copyRelativeFilePath")</p><p>rule: file create sibling , imp:user.vscode_and_wait("explorer.newFile")</p><p>rule: file create , imp:user.vscode("workbench.action.files.newUntitledFile")</p><p>rule: file create relative , imp:user.vscode("fileutils.newFile")</p><p>rule: file create root , imp:user.vscode("fileutils.newFileAtRoot")</p><p>rule: file rename , imp:user.vscode("fileutils.renameFile")
		sleep(150ms)</p><p>rule: file move , imp:user.vscode("fileutils.moveFile")
		sleep(150ms)</p><p>rule: file clone , imp:user.vscode("fileutils.duplicateFile")
		sleep(150ms)</p><p>rule: file delete , imp:user.vscode("fileutils.removeFile")
		sleep(150ms)</p><p>rule: file open folder , imp:user.vscode("revealFileInOS")</p><p>rule: file reveal , imp:user.vscode("workbench.files.action.showActiveFileInExplorer")</p><p>rule: save ugly , imp:user.vscode("workbench.action.files.saveWithoutFormatting")</p><p>rule: suggest show , imp:user.vscode("editor.action.triggerSuggest")</p><p>rule: hint show , imp:user.vscode("editor.action.triggerParameterHints")</p><p>rule: definition show , imp:user.vscode("editor.action.revealDefinition")</p><p>rule: definition peek , imp:user.vscode("editor.action.peekDefinition")</p><p>rule: definition side , imp:user.vscode("editor.action.revealDefinitionAside")</p><p>rule: references show , imp:user.vscode("editor.action.goToReferences")</p><p>rule: hierarchy peek , imp:user.vscode("editor.showCallHierarchy")</p><p>rule: references find , imp:user.vscode("references-view.find")</p><p>rule: format that , imp:user.vscode("editor.action.formatDocument")</p><p>rule: format selection , imp:user.vscode("editor.action.formatSelection")</p><p>rule: imports fix , imp:user.vscode("editor.action.organizeImports")</p><p>rule: problem next , imp:user.vscode("editor.action.marker.nextInFiles")</p><p>rule: problem last , imp:user.vscode("editor.action.marker.prevInFiles")</p><p>rule: problem fix , imp:user.vscode("problems.action.showQuickFixes")</p><p>rule: rename that , imp:user.vscode("editor.action.rename")</p><p>rule: refactor that , imp:user.vscode("editor.action.refactor")</p><p>rule: whitespace trim , imp:user.vscode("editor.action.trimTrailingWhitespace")</p><p>rule: language switch , imp:user.vscode("workbench.action.editor.changeLanguageMode")</p><p>rule: refactor rename , imp:user.vscode("editor.action.rename")</p><p>rule: refactor this , imp:user.vscode("editor.action.refactor")</p><p>rule: (go declaration | follow) , imp:user.vscode("editor.action.revealDefinition")</p><p>rule: go back , imp:user.vscode("workbench.action.navigateBack")</p><p>rule: go forward , imp:user.vscode("workbench.action.navigateForward")</p><p>rule: go implementation , imp:user.vscode("editor.action.goToImplementation")</p><p>rule: go type , imp:user.vscode("editor.action.goToTypeDefinition")</p><p>rule: go usage , imp:user.vscode("references-view.find")</p><p>rule: go recent [&lt;user.text&gt;] , imp:user.vscode("workbench.action.openRecent")
		sleep(50ms)
		insert(text or "")
		sleep(250ms)</p><p>rule: go edit , imp:user.vscode("workbench.action.navigateToLastEditLocation")</p><p>rule: bar marks , imp:user.vscode("workbench.view.extension.bookmarks")</p><p>rule: go marks , imp:user.deprecate_command("2023-06-06", "go marks", "bar marks")
		user.vscode("workbench.view.extension.bookmarks")</p><p>rule: toggle mark , imp:user.vscode("bookmarks.toggle")</p><p>rule: go next mark , imp:user.vscode("bookmarks.jumpToNext")</p><p>rule: go last mark , imp:user.vscode("bookmarks.jumpToPrevious")</p><p>rule: close other tabs , imp:user.vscode("workbench.action.closeOtherEditors")</p><p>rule: close all tabs , imp:user.vscode("workbench.action.closeAllEditors")</p><p>rule: close tabs way right , imp:user.vscode("workbench.action.closeEditorsToTheRight")</p><p>rule: close tabs way left , imp:user.vscode("workbench.action.closeEditorsToTheLeft")</p><p>rule: fold that , imp:user.vscode("editor.fold")</p><p>rule: unfold that , imp:user.vscode("editor.unfold")</p><p>rule: fold those , imp:user.vscode("editor.foldAllMarkerRegions")</p><p>rule: unfold those , imp:user.vscode("editor.unfoldRecursively")</p><p>rule: fold all , imp:user.vscode("editor.foldAll")</p><p>rule: unfold all , imp:user.vscode("editor.unfoldAll")</p><p>rule: fold comments , imp:user.vscode("editor.foldAllBlockComments")</p><p>rule: fold one , imp:user.vscode("editor.foldLevel1")</p><p>rule: fold two , imp:user.vscode("editor.foldLevel2")</p><p>rule: fold three , imp:user.vscode("editor.foldLevel3")</p><p>rule: fold four , imp:user.vscode("editor.foldLevel4")</p><p>rule: fold five , imp:user.vscode("editor.foldLevel5")</p><p>rule: fold six , imp:user.vscode("editor.foldLevel6")</p><p>rule: fold seven , imp:user.vscode("editor.foldLevel7")</p><p>rule: git branch , imp:user.vscode("git.branchFrom")</p><p>rule: git branch this , imp:user.vscode("git.branch")</p><p>rule: git checkout [&lt;user.text&gt;] , imp:user.vscode("git.checkout")
		sleep(50ms)
		insert(text or "")</p><p>rule: git commit [&lt;user.text&gt;] , imp:user.vscode("git.commitStaged")
		sleep(100ms)
		user.insert_formatted(text or "", "CAPITALIZE_FIRST_WORD")</p><p>rule: git commit undo , imp:user.vscode("git.undoCommit")</p><p>rule: git commit amend , imp:user.vscode("git.commitStagedAmend")</p><p>rule: git diff , imp:user.vscode("git.openChange")</p><p>rule: git fetch , imp:user.vscode("git.fetch")</p><p>rule: git fetch all , imp:user.vscode("git.fetchAll")</p><p>rule: git ignore , imp:user.vscode("git.ignore")</p><p>rule: git merge , imp:user.vscode("git.merge")</p><p>rule: git output , imp:user.vscode("git.showOutput")</p><p>rule: git pull , imp:user.vscode("git.pullRebase")</p><p>rule: git push , imp:user.vscode("git.push")</p><p>rule: git push force , imp:user.vscode("git.pushForce")</p><p>rule: git rebase abort , imp:user.vscode("git.rebaseAbort")</p><p>rule: git reveal , imp:user.vscode("git.revealInExplorer")</p><p>rule: git revert , imp:user.vscode("git.revertChange")</p><p>rule: git stash , imp:user.vscode("git.stash")</p><p>rule: git stash pop , imp:user.vscode("git.stashPop")</p><p>rule: git status , imp:user.vscode("workbench.scm.focus")</p><p>rule: git stage , imp:user.vscode("git.stage")</p><p>rule: git stage all , imp:user.vscode("git.stageAll")</p><p>rule: git sync , imp:user.vscode("git.sync")</p><p>rule: git unstage , imp:user.vscode("git.unstage")</p><p>rule: git unstage all , imp:user.vscode("git.unstageAll")</p><p>rule: pull request , imp:user.vscode("pr.create")</p><p>rule: change next , imp:key(alt-f5)</p><p>rule: change last , imp:key(shift-alt-f5)</p><p>rule: test run , imp:user.vscode("testing.runAtCursor")</p><p>rule: test run file , imp:user.vscode("testing.runCurrentFile")</p><p>rule: test run all , imp:user.vscode("testing.runAll")</p><p>rule: test run failed , imp:user.vscode("testing.reRunFailTests")</p><p>rule: test run last , imp:user.vscode("testing.reRunLastRun")</p><p>rule: test debug , imp:user.vscode("testing.debugAtCursor")</p><p>rule: test debug file , imp:user.vscode("testing.debugCurrentFile")</p><p>rule: test debug all , imp:user.vscode("testing.debugAll")</p><p>rule: test debug failed , imp:user.vscode("testing.debugFailTests")</p><p>rule: test debug last , imp:user.vscode("testing.debugLastRun")</p><p>rule: test cancel , imp:user.vscode("testing.cancelRun")</p><p>rule: break point , imp:user.vscode("editor.debug.action.toggleBreakpoint")</p><p>rule: step over , imp:user.vscode("workbench.action.debug.stepOver")</p><p>rule: debug step into , imp:user.vscode("workbench.action.debug.stepInto")</p><p>rule: debug step out [of] , imp:user.vscode("workbench.action.debug.stepOut")</p><p>rule: debug start , imp:user.vscode("workbench.action.debug.start")</p><p>rule: debug pause , imp:user.vscode("workbench.action.debug.pause")</p><p>rule: debug stopper , imp:user.vscode("workbench.action.debug.stop")</p><p>rule: debug continue , imp:user.vscode("workbench.action.debug.continue")</p><p>rule: debug restart , imp:user.vscode("workbench.action.debug.restart")</p><p>rule: debug console , imp:user.vscode("workbench.debug.action.toggleRepl")</p><p>rule: debug clean , imp:user.vscode("workbench.debug.panel.action.clearReplAction")</p><p>rule: terminal external , imp:user.vscode("workbench.action.terminal.openNativeConsole")</p><p>rule: terminal new , imp:user.vscode("workbench.action.terminal.new")</p><p>rule: terminal next , imp:user.vscode("workbench.action.terminal.focusNext")</p><p>rule: terminal last , imp:user.vscode("workbench.action.terminal.focusPrevious")</p><p>rule: terminal split , imp:user.vscode("workbench.action.terminal.split")</p><p>rule: terminal zoom , imp:user.vscode("workbench.action.toggleMaximizedPanel")</p><p>rule: terminal trash , imp:user.vscode("workbench.action.terminal.kill")</p><p>rule: terminal toggle , imp:user.vscode_and_wait("workbench.action.terminal.toggleTerminal")</p><p>rule: terminal scroll up , imp:user.vscode("workbench.action.terminal.scrollUp")</p><p>rule: terminal scroll down , imp:user.vscode("workbench.action.terminal.scrollDown")</p><p>rule: terminal &lt;number_small&gt; , imp:user.vscode_terminal(number_small)</p><p>rule: copy line down , imp:user.vscode("editor.action.copyLinesDownAction")</p><p>rule: copy line up , imp:user.vscode("editor.action.copyLinesUpAction")</p><p>rule: select less , imp:user.vscode("editor.action.smartSelect.shrink")</p><p>rule: select (more | this) , imp:user.vscode("editor.action.smartSelect.expand")</p><p>rule: minimap , imp:user.vscode("editor.action.toggleMinimap")</p><p>rule: maximize , imp:user.vscode("workbench.action.minimizeOtherEditors")</p><p>rule: restore , imp:user.vscode("workbench.action.evenEditorWidths")</p><p>rule: select breadcrumb , imp:user.vscode("breadcrumbs.focusAndSelect")</p><p>rule: replace here , imp:user.replace("")
		key(cmd-alt-l)
		</p><p>rule: hover show , imp:user.vscode("editor.action.showHover")</p><p>rule: join lines , imp:user.vscode("editor.action.joinLines")</p><p>rule: full screen , imp:user.vscode("workbench.action.toggleFullScreen")</p><p>rule: curse undo , imp:user.vscode("cursorUndo")</p><p>rule: curse redo , imp:user.vscode("cursorRedo")</p><p>rule: select word , imp:user.vscode("editor.action.addSelectionToNextFindMatch")</p><p>rule: skip word , imp:user.vscode("editor.action.moveSelectionToNextFindMatch")</p><p>rule: cell next , imp:user.vscode("notebook.focusNextEditor")</p><p>rule: cell last , imp:user.vscode("notebook.focusPreviousEditor")</p><p>rule: cell run above , imp:user.vscode("notebook.cell.executeCellsAbove")</p><p>rule: cell run , imp:user.vscode("notebook.cell.execute")</p><p>rule: install local , imp:user.vscode("workbench.extensions.action.installVSIX")</p><p>rule: preview markdown , imp:user.vscode("markdown.showPreview")</p><p style="page-break-after: always;">&nbsp;</p><h2>windows explorer</h2><p>rule: go &lt;user.letter&gt; , imp:user.file_manager_open_volume("{letter}:")</p><p>rule: go app data , imp:user.file_manager_open_directory("%AppData%")</p><p>rule: go program files , imp:user.file_manager_open_directory("%programfiles%")</p><h2>windows terminal</h2><p>rule: settings open , imp:key(ctrl-,)</p><p>rule: focus left , imp:key(ctrl-alt-shift-left)</p><p>rule: focus right , imp:key(ctrl-alt-shift-right)</p><p>rule: focus up , imp:key(ctrl-alt-shift-up)</p><p>rule: focus down , imp:key(ctrl-alt-shift-down)</p><p>rule: term menu , imp:key(ctrl-shift-f1)</p><p>rule: find it , imp:edit.find()</p><p>rule: find it &lt;phrase&gt; , imp:# handle consecutive finds by first escaping out of any previous one
		key(escape)
		# make it so
		edit.find("{phrase}\n")</p><h2>wsl</h2><p>rule: go &lt;user.letter&gt; , imp:user.file_manager_open_volume("/mnt/{letter}")</p><p>rule: (wsl | weasel) reset path detection , imp:user.wsl_reset_path_detection()</p><p>rule: (wsl | weasel) speak , imp:user.wsl_speak()</p><h2>abbreviate</h2><p>rule: (abbreviate | abreviate | brief) {user.abbreviation} , imp:"{abbreviation}"</p><h2>edit</h2><p>rule: zoom in , imp:edit.zoom_in()</p><p>rule: zoom out , imp:edit.zoom_out()</p><p>rule: zoom reset , imp:edit.zoom_reset()</p><p>rule: find it , imp:edit.find()</p><p>rule: next one , imp:edit.find_next()</p><p>rule: scroll up , imp:edit.page_up()</p><p>rule: scroll down , imp:edit.page_down()</p><p>rule: go word left , imp:edit.word_left()</p><p>rule: go word right , imp:edit.word_right()</p><p>rule: go left , imp:edit.left()</p><p>rule: go right , imp:edit.right()</p><p>rule: go up , imp:edit.up()</p><p>rule: go down , imp:edit.down()</p><p>rule: go line start | head , imp:edit.line_start()</p><p>rule: go line end | tail , imp:edit.line_end()</p><p>rule: go way left , imp:edit.line_start()
		edit.line_start()</p><p>rule: go way right , imp:edit.line_end()</p><p>rule: go way up , imp:edit.file_start()</p><p>rule: go way down , imp:edit.file_end()</p><p>rule: go top , imp:edit.file_start()</p><p>rule: go bottom , imp:edit.file_end()</p><p>rule: go page up , imp:edit.page_up()</p><p>rule: go page down , imp:edit.page_down()</p><p>rule: select all , imp:edit.select_all()</p><p>rule: select line , imp:edit.select_line()</p><p>rule: select line start , imp:user.select_line_start()</p><p>rule: select line end , imp:user.select_line_end()</p><p>rule: select left , imp:edit.extend_left()</p><p>rule: select right , imp:edit.extend_right()</p><p>rule: select up , imp:edit.extend_line_up()</p><p>rule: select down , imp:edit.extend_line_down()</p><p>rule: select word , imp:edit.select_word()</p><p>rule: select word left , imp:edit.extend_word_left()</p><p>rule: select word right , imp:edit.extend_word_right()</p><p>rule: select way left , imp:edit.extend_line_start()</p><p>rule: select way right , imp:edit.extend_line_end()</p><p>rule: select way up , imp:edit.extend_file_start()</p><p>rule: select way down , imp:edit.extend_file_end()</p><p>rule: indent [more] , imp:edit.indent_more()</p><p>rule: (indent less | out dent) , imp:edit.indent_less()</p><p>rule: clear all , imp:user.delete_all()</p><p>rule: clear line , imp:edit.delete_line()</p><p>rule: clear line start , imp:user.delete_line_start()</p><p>rule: clear line end , imp:user.delete_line_end()</p><p>rule: clear left , imp:edit.delete()</p><p>rule: clear right , imp:user.delete_right()</p><p>rule: clear up , imp:edit.extend_line_up()
		edit.delete()
		</p><p>rule: clear down , imp:edit.extend_line_down()
		edit.delete()
		</p><p>rule: clear word , imp:edit.delete_word()</p><p>rule: clear word left , imp:edit.extend_word_left()
		edit.delete()
		</p><p>rule: clear word right , imp:edit.extend_word_right()
		edit.delete()
		</p><p>rule: clear way left , imp:edit.extend_line_start()
		edit.delete()
		</p><p>rule: clear way right , imp:edit.extend_line_end()
		edit.delete()
		</p><p>rule: clear way up , imp:edit.extend_file_start()
		edit.delete()
		</p><p>rule: clear way down , imp:edit.extend_file_end()
		edit.delete()
		
		# Copy</p><p>rule: copy that , imp:edit.copy()</p><p>rule: copy all , imp:user.copy_all()</p><p>rule: copy line , imp:user.copy_line()</p><p>rule: copy line start , imp:user.copy_line_start()</p><p>rule: copy line end , imp:user.copy_line_end()</p><p>rule: copy word , imp:user.copy_word()</p><p>rule: copy word left , imp:user.copy_word_left()</p><p>rule: copy word right , imp:user.copy_word_right()</p><p>rule: cut that , imp:edit.cut()</p><p>rule: cut all , imp:user.cut_all()</p><p>rule: cut line , imp:user.cut_line()</p><p>rule: cut line start , imp:user.cut_line_start()</p><p>rule: cut line end , imp:user.cut_line_end()</p><p>rule: cut word , imp:user.cut_word()</p><p>rule: cut word left , imp:user.cut_word_left()</p><p>rule: cut word right , imp:user.cut_word_right()</p><p>rule: (pace | paste) that , imp:edit.paste()</p><p>rule: (pace | paste) enter , imp:edit.paste()
		key(enter)</p><p>rule: paste match , imp:edit.paste_match_style()</p><p>rule: (pace | paste) all , imp:user.paste_all()</p><p>rule: (pace | paste) line , imp:user.paste_line()</p><p>rule: (pace | paste) line start , imp:user.paste_line_start()</p><p>rule: (pace | paste) line end , imp:user.paste_line_end()</p><p>rule: (pace | paste) word , imp:user.paste_word()</p><p>rule: clone that , imp:edit.selection_clone()</p><p>rule: clone line , imp:edit.line_clone()</p><p>rule: new line above , imp:edit.line_insert_up()</p><p>rule: new line below | slap , imp:edit.line_insert_down()</p><p>rule: (pad | padding) , imp:user.insert_between(" ", " ")</p><p>rule: (pad | padding) &lt;user.symbol_key&gt;+ , imp:insert(" ")
		user.insert_many(symbol_key_list)
		insert(" ")
		
		# Undo/redo</p><p>rule: undo that , imp:edit.undo()</p><p>rule: redo that , imp:edit.redo()</p><p>rule: file save , imp:edit.save()</p><p>rule: file save all , imp:edit.save_all()</p><p style="page-break-after: always;">&nbsp;</p><h2>edit settings</h2><p>rule: customize {user.talon_settings_csv} , imp:user.edit_text_file(talon_settings_csv)
		sleep(500ms)
		edit.file_end()</p><h2>file extension</h2><p>rule: {user.file_extension} , imp:"{file_extension}"</p><h2>help</h2><p>rule: help alphabet , imp:user.help_list("user.letter")</p><p>rule: help symbols , imp:user.help_list("user.symbol_key")</p><p>rule: help numbers , imp:user.help_list("user.number_key")</p><p>rule: help punctuation , imp:user.help_list("user.punctuation")</p><p>rule: help modifier , imp:user.help_list("user.modifier_key")</p><p>rule: help special keys , imp:user.help_list("user.special_key")</p><p>rule: help function keys , imp:user.help_list("user.function_key")</p><p>rule: help arrows , imp:user.help_list("user.arrow_key")</p><p>rule: (help formatters | help format | format help) , imp:user.help_formatters(user.get_formatters_words())</p><p>rule: help context , imp:user.help_context()</p><p>rule: help active , imp:user.help_context_enabled()</p><p>rule: help search &lt;user.text&gt; , imp:user.help_search(text)</p><p>rule: help context {user.help_contexts} , imp:user.help_selected_context(help_contexts)</p><p>rule: help help , imp:user.help_search("help")</p><p>rule: help scope , imp:user.help_scope_toggle()</p><h2>help open</h2><p>rule: help next , imp:user.help_next()</p><p>rule: help previous , imp:user.help_previous()</p><p>rule: help &lt;number&gt; , imp:user.help_select_index(number - 1)</p><p>rule: help return , imp:user.help_return()</p><p>rule: help refresh , imp:user.help_refresh()</p><p>rule: help close , imp:user.help_hide()</p><p style="page-break-after: always;">&nbsp;</p><h2>help scope open</h2><p>rule: scope (hide | close) , imp:user.help_scope_toggle()</p><h2>homophones</h2><p>rule: phones &lt;user.homophones_canonical&gt; , imp:user.homophones_show(homophones_canonical)</p><p>rule: phones that , imp:user.homophones_show_auto()</p><p>rule: phones force &lt;user.homophones_canonical&gt; , imp:user.homophones_force_show(homophones_canonical)</p><p>rule: phones force , imp:user.homophones_force_show_selection()</p><p>rule: phones hide , imp:user.homophones_hide()</p><p>rule: phones word , imp:edit.select_word()
		user.homophones_show_selection()</p><p>rule: phones [&lt;user.ordinals&gt;] word left , imp:n = ordinals or 1
		user.words_left(n - 1)
		edit.extend_word_left()
		user.homophones_show_selection()</p><p>rule: phones [&lt;user.ordinals&gt;] word right , imp:n = ordinals or 1
		user.words_right(n - 1)
		edit.extend_word_right()
		user.homophones_show_selection()</p><h2>homophones open</h2><p>rule: choose &lt;number_small&gt; , imp:result = user.homophones_select(number_small)
		insert(result)
		user.homophones_hide()</p><p>rule: choose &lt;user.formatters&gt; &lt;number_small&gt; , imp:result = user.homophones_select(number_small)
		insert(user.formatted_text(result, formatters))
		user.homophones_hide()</p><h2>keys</h2><p>rule: go &lt;user.arrow_keys&gt; , imp:user.move_cursor(arrow_keys)</p><p>rule: &lt;user.letter&gt; , imp:key(letter)</p><p>rule: (ship | uppercase) &lt;user.letters&gt; [(lowercase | sunk)] , imp:user.insert_formatted(letters, "ALL_CAPS")</p><p>rule: &lt;user.symbol_key&gt; , imp:key(symbol_key)</p><p>rule: &lt;user.function_key&gt; , imp:key(function_key)</p><p>rule: &lt;user.special_key&gt; , imp:key(special_key)</p><p>rule: &lt;user.modifiers&gt; &lt;user.unmodified_key&gt; , imp:key("{modifiers}-{unmodified_key}")</p><p>rule: press &lt;user.modifiers&gt; , imp:key(modifiers)</p><p>rule: press &lt;user.keys&gt; , imp:key(keys)</p><h2>dictation mode</h2><p>rule: press &lt;user.modifiers&gt; , imp:key(modifiers)</p><p>rule: press &lt;user.keys&gt; , imp:key(keys)</p><p>rule: &lt;user.raw_prose&gt; , imp:user.dictation_insert(raw_prose)</p><p>rule: cap , imp:user.dictation_format_cap()</p><p>rule: (no cap | no-caps) , imp:user.dictation_format_no_cap()</p><p>rule: (no space | no-space) , imp:user.dictation_format_no_space()</p><p>rule: cap that , imp:user.dictation_reformat_cap()</p><p>rule: (no cap | no-caps) that , imp:user.dictation_reformat_no_cap()</p><p>rule: (no space | no-space) that , imp:user.dictation_reformat_no_space()</p><p>rule: go up &lt;number_small&gt; (line | lines) , imp:edit.up()
		repeat(number_small - 1)</p><p>rule: go down &lt;number_small&gt; (line | lines) , imp:edit.down()
		repeat(number_small - 1)</p><p>rule: go left &lt;number_small&gt; (word | words) , imp:edit.word_left()
		repeat(number_small - 1)</p><p>rule: go right &lt;number_small&gt; (word | words) , imp:edit.word_right()
		repeat(number_small - 1)</p><p>rule: go line start , imp:edit.line_start()</p><p>rule: go line end , imp:edit.line_end()</p><p>rule: select left &lt;number_small&gt; (word | words) , imp:edit.extend_word_left()
		repeat(number_small - 1)</p><p>rule: select right &lt;number_small&gt; (word | words) , imp:edit.extend_word_right()
		repeat(number_small - 1)</p><p>rule: select left &lt;number_small&gt; (character | characters) , imp:edit.extend_left()
		repeat(number_small - 1)</p><p>rule: select right &lt;number_small&gt; (character | characters) , imp:edit.extend_right()
		repeat(number_small - 1)</p><p>rule: clear left &lt;number_small&gt; (word | words) , imp:edit.extend_word_left()
		repeat(number_small - 1)
		edit.delete()</p><p>rule: clear right &lt;number_small&gt; (word | words) , imp:edit.extend_word_right()
		repeat(number_small - 1)
		edit.delete()</p><p>rule: clear left &lt;number_small&gt; (character | characters) , imp:edit.extend_left()
		repeat(number_small - 1)
		edit.delete()</p><p>rule: clear right &lt;number_small&gt; (character | characters) , imp:edit.extend_right()
		repeat(number_small - 1)
		edit.delete()
		
		# Formatting</p><p>rule: formatted &lt;user.format_text&gt; , imp:user.dictation_insert_raw(format_text)</p><p>rule: format selection &lt;user.formatters&gt; , imp:user.formatters_reformat_selection(formatters)</p><p>rule: nope that | scratch that , imp:user.clear_last_phrase()</p><p>rule: (nope | scratch) selection , imp:edit.delete()</p><p>rule: select that , imp:user.select_last_phrase()</p><p>rule: spell that &lt;user.letters&gt; , imp:user.dictation_insert(letters)</p><p>rule: spell that &lt;user.formatters&gt; &lt;user.letters&gt; , imp:result = user.formatted_text(letters, formatters)
		user.dictation_insert_raw(result)
		
		# Escape, type things that would otherwise be commands</p><p>rule: escape &lt;user.text&gt; , imp:user.dictation_insert(user.text)</p><p style="page-break-after: always;">&nbsp;</p><h2>dragon mode</h2><p>rule: dragon mode , imp:user.dragon_mode()</p><p>rule: talon mode , imp:user.talon_mode()</p><h2>language modes</h2><p>rule: force {user.language_mode} , imp:user.code_set_language_mode(language_mode)</p><p>rule: clear language modes , imp:user.code_clear_language_mode()</p><h2>modes</h2><p>rule: dictation mode , imp:mode.disable("sleep")
		mode.disable("command")
		mode.enable("dictation")
		user.code_clear_language_mode()
		user.gdb_disable()</p><p>rule: command mode , imp:mode.disable("sleep")
		mode.disable("dictation")
		mode.enable("command")</p><h2>sleep mode</h2><p>rule: (welcome back)+ , imp:user.mouse_wake()
		user.history_enable()
		user.talon_mode()
		</p><p>rule: (talon wake)+ , imp:speech.enable()</p><h2>sleep mode not dragon</h2><p>rule: (wake up)+ , imp:speech.enable()</p><h2>sleep mode wav2letter</h2><p>rule: &lt;phrase&gt; , imp:skip()</p><h2>to sleep mode</h2><p>rule: sleep all [&lt;phrase&gt;] , imp:user.switcher_hide_running()
		user.history_disable()
		user.homophones_hide()
		user.help_hide()
		user.mouse_sleep()
		speech.disable()
		user.engine_sleep()
		</p><p>rule: talon sleep [&lt;phrase&gt;] , imp:speech.disable()</p><h2>to sleep mode not dragon</h2><p>rule: go to sleep [&lt;phrase&gt;] , imp:speech.disable()</p><h2>mouse grid</h2><p>rule: M grid , imp:app.notify("please use the voice command 'mouse grid' instead of 'm grid'")
		user.grid_select_screen(1)
		user.grid_activate()</p><h2>mouse grid always</h2><p>rule: mouse grid , imp:user.grid_select_screen(1)
		user.grid_activate()
		</p><p>rule: grid win , imp:user.grid_place_window()
		user.grid_activate()
		</p><p>rule: grid &lt;user.number_key&gt;+ , imp:user.grid_activate()
		user.grid_narrow_list(number_key_list)
		</p><p>rule: grid screen [&lt;number&gt;] , imp:user.grid_select_screen(number or 1)
		user.grid_activate()</p><h2>mouse grid open</h2><p>rule: &lt;user.number_key&gt; , imp:user.grid_narrow(number_key)</p><p>rule: grid off , imp:user.grid_close()</p><p>rule: grid reset , imp:user.grid_reset()</p><p>rule: grid back , imp:user.grid_go_back()</p><p style="page-break-after: always;">&nbsp;</p><h2>numbers</h2><p>rule: &lt;user.number_string&gt; , imp:"{number_string}"</p><h2>screens</h2><p>rule: screen numbers , imp:user.screens_show_numbering()</p><h2>snippets</h2><p>rule: snip {user.snippet} , imp:user.insert_snippet_by_name(snippet)</p><p>rule: snip {user.snippet_with_phrase} &lt;user.text&gt; , imp:user.insert_snippet_by_name_with_phrase(snippet_with_phrase, text)</p><h2>text</h2><p>rule: phrase &lt;user.text&gt; , imp:user.add_phrase_to_history(text)
		insert(text)</p><p>rule: phrase &lt;user.text&gt; over , imp:user.add_phrase_to_history(text)
		insert(text)</p><p>rule: {user.prose_formatter} &lt;user.prose&gt; , imp:user.insert_formatted(prose, prose_formatter)</p><p>rule: {user.prose_formatter} &lt;user.prose&gt; over , imp:user.insert_formatted(prose, prose_formatter)</p><p>rule: &lt;user.format_code&gt;+ , imp:user.insert_many(format_code_list)</p><p>rule: &lt;user.format_code&gt;+ over , imp:user.insert_many(format_code_list)</p><p>rule: &lt;user.formatters&gt; that , imp:user.formatters_reformat_selection(user.formatters)</p><p>rule: word &lt;user.word&gt; , imp:user.add_phrase_to_history(word)
		insert(word)</p><p>rule: proud &lt;user.word&gt; , imp:user.insert_formatted(word, "CAPITALIZE_FIRST_WORD")</p><p>rule: recent list , imp:user.toggle_phrase_history()</p><p>rule: recent close , imp:user.phrase_history_hide()</p><p>rule: recent repeat &lt;number_small&gt; , imp:recent_phrase = user.get_recent_phrase(number_small)
		user.add_phrase_to_history(recent_phrase)
		insert(recent_phrase)</p><p>rule: recent copy &lt;number_small&gt; , imp:clip.set_text(user.get_recent_phrase(number_small))</p><p>rule: select that , imp:user.select_last_phrase()</p><p>rule: before that , imp:user.before_last_phrase()</p><p>rule: nope that | scratch that , imp:user.clear_last_phrase()</p><p>rule: nope that was &lt;user.formatters&gt; , imp:user.formatters_reformat_last(formatters)</p><p style="page-break-after: always;">&nbsp;</p><h2>edit vocabulary</h2><p>rule: copy to vocab [as &lt;phrase&gt;] , imp:user.add_selection_to_vocabulary(phrase or "")</p><p>rule: copy name to vocab [as &lt;phrase&gt;] , imp:user.add_selection_to_vocabulary(phrase or "", "name")
		# Automatically adds plural form by simply appending "s".</p><p>rule: copy noun to vocab [as &lt;phrase&gt;] , imp:user.add_selection_to_vocabulary(phrase or "", "noun")</p><p>rule: copy to replacements as &lt;phrase&gt; , imp:user.add_selection_to_words_to_replace(phrase)</p><p>rule: copy name to replacements as &lt;phrase&gt; , imp:user.add_selection_to_words_to_replace(phrase, "name")
		# Automatically adds plural form by simply appending "s".</p><p>rule: copy noun to replacements as &lt;phrase&gt; , imp:user.add_selection_to_words_to_replace(phrase, "noun")</p><h2>websites and search engines</h2><p>rule: open {user.website} , imp:user.open_url(website)</p><p>rule: open that , imp:user.open_url(edit.selected_text())</p><p>rule: open paste , imp:user.open_url(clip.text())</p><p>rule: {user.search_engine} hunt &lt;user.text&gt; , imp:user.search_with_search_engine(search_engine, user.text)</p><p>rule: {user.search_engine} (that | this) , imp:text = edit.selected_text()
		user.search_with_search_engine(search_engine, text)</p><p>rule: {user.search_engine} paste , imp:user.search_with_search_engine(search_engine, clip.text())</p><h2>tabs</h2><p>rule: tab (open | new) , imp:app.tab_open()</p><p>rule: tab (last | previous) , imp:app.tab_previous()</p><p>rule: tab next , imp:app.tab_next()</p><p>rule: tab close , imp:user.tab_close_wrapper()</p><p>rule: tab (reopen | restore) , imp:app.tab_reopen()</p><p>rule: go tab &lt;number&gt; , imp:user.tab_jump(number)</p><p>rule: go tab final , imp:user.tab_final()</p><p>rule: tab duplicate , imp:user.tab_duplicate()</p><h2>window management</h2><p>rule: window (new | open) , imp:app.window_open()</p><p>rule: window next , imp:app.window_next()</p><p>rule: window last , imp:app.window_previous()</p><p>rule: window close , imp:app.window_close()</p><p>rule: window hide , imp:app.window_hide()</p><p>rule: focus &lt;user.running_applications&gt; , imp:user.switcher_focus(running_applications)</p><p>rule: focus , imp:user.switcher_menu()</p><p>rule: focus last , imp:user.switcher_focus_last()</p><p>rule: running list , imp:user.switcher_toggle_running()</p><p>rule: running close , imp:user.switcher_hide_running()</p><p>rule: launch &lt;user.launch_applications&gt; , imp:user.switcher_launch(launch_applications)</p><p>rule: snap &lt;user.window_snap_position&gt; , imp:user.snap_window(window_snap_position)</p><p>rule: snap next [screen] , imp:user.move_window_next_screen()</p><p>rule: snap last [screen] , imp:user.move_window_previous_screen()</p><p>rule: snap screen &lt;number&gt; , imp:user.move_window_to_screen(number)</p><p>rule: snap &lt;user.running_applications&gt; &lt;user.window_snap_position&gt; , imp:user.snap_app(running_applications, window_snap_position)</p><p>rule: snap &lt;user.running_applications&gt; [screen] &lt;number&gt; , imp:user.move_app_to_screen(running_applications, number)</p><p style="page-break-after: always;">&nbsp;</p><h2>simple test</h2><p>rule: select everything , imp:key(ctrl-a)
		</p><h2>batch</h2><p>rule: soft exit , imp:"exit /B 1\n"</p><p>rule: hard exit , imp:"exit 1\n"</p><p>rule: echo , imp:"echo "</p><p>rule: echo off , imp:"@echo off\n"</p><p>rule: call , imp:"call "</p><p>rule: call shell , imp:"call cmd \\c "</p><p>rule: if error , imp:"if errorlevel 1 "</p><p>rule: go to , imp:"goto "</p><p>rule: delayed expansion , imp:"SETLOCAL EnableDelayedExpansion\n"</p><p>rule: arg &lt;number_small&gt; , imp:"%{number_small}"</p><h2>c</h2><p>rule: state include , imp:insert("#include ")</p><p>rule: state include system , imp:user.insert_between("#include &lt;", "&gt;")</p><p>rule: state include local , imp:user.insert_between('#include "', '"')</p><p>rule: state type deaf , imp:insert("typedef ")</p><p>rule: state type deaf struct , imp:insert("typedef struct")
		insert("{\n\n}")
		edit.up()
		key('tab')
		
		# XXX - create a preprocessor tag for these, as they will match cpp, etc</p><p>rule: state define , imp:"#define "</p><p>rule: state (undefine | undeaf) , imp:"#undef "</p><p>rule: state if (define | deaf) , imp:"#ifdef "</p><p>rule: [state] define &lt;user.text&gt; , imp:"#define {user.formatted_text(text, 'ALL_CAPS,SNAKE_CASE')}"</p><p>rule: [state] (undefine | undeaf) &lt;user.text&gt; , imp:"#undef {user.formatted_text(text, 'ALL_CAPS,SNAKE_CASE')}"</p><p>rule: [state] if (define | deaf) &lt;user.text&gt; , imp:"#ifdef {user.formatted_text(text, 'ALL_CAPS,SNAKE_CASE')}"
		
		# XXX - preprocessor instead of pre?</p><p>rule: state pre if , imp:"#if "</p><p>rule: state error , imp:"#error "</p><p>rule: state pre else if , imp:"#elif "</p><p>rule: state pre end , imp:"#endif "</p><p>rule: state pragma , imp:"#pragma "</p><p>rule: state default , imp:"default:\nbreak;"</p><p>rule: push braces , imp:edit.line_end()
		#insert("{")
		#key(enter)
		insert("{}")
		edit.left()
		key(enter)
		key(enter)
		edit.up()
		
		# Declare variables or structs etc.
		# Ex. * int myList</p><p>rule: &lt;user.c_variable&gt; &lt;phrase&gt; , imp:insert("{c_variable} ")
		insert(user.formatted_text(phrase, "PRIVATE_CAMEL_CASE,NO_SPACES"))
		</p><p>rule: &lt;user.c_variable&gt; &lt;user.letter&gt; , imp:insert("{c_variable} {letter} ")</p><p>rule: cast to &lt;user.c_cast&gt; , imp:"{c_cast}"</p><p>rule: standard cast to &lt;user.stdint_cast&gt; , imp:"{stdint_cast}"</p><p>rule: &lt;user.c_types&gt; , imp:"{c_types}"</p><p>rule: &lt;user.c_pointers&gt; , imp:"{c_pointers}"</p><p>rule: &lt;user.c_keywords&gt; , imp:"{c_keywords}"</p><p>rule: &lt;user.c_signed&gt; , imp:"{c_signed}"</p><p>rule: standard &lt;user.stdint_types&gt; , imp:"{stdint_types}"</p><p>rule: int main , imp:user.insert_between("int main(", ")")</p><p>rule: toggle includes , imp:user.code_toggle_libraries()</p><p>rule: include &lt;user.code_libraries&gt; , imp:user.code_insert_library(code_libraries, "")
		key(end enter)</p><p style="page-break-after: always;">&nbsp;</p><h2>css</h2><p>rule: block , imp:user.code_block()</p><p>rule: attribute [&lt;user.text&gt;] , imp:name = user.formatted_text(text or "", "DASH_SEPARATED")
		user.insert_between("[{name}", "]")
		</p><p>rule: prop &lt;user.text&gt; , imp:name = user.formatted_text(text, "DASH_SEPARATED")
		user.insert_between("{name}: ", ";")
		
		# for media/supports queries, or if you don't like prop</p><p>rule: rule &lt;user.text&gt; , imp:name = user.formatted_text(text, "DASH_SEPARATED")
		insert("{name}: ")
		</p><p>rule: value &lt;user.number_string&gt; [{user.css_unit}] , imp:"{number_string}{css_unit or ''}"</p><p>rule: value &lt;user.number_string&gt; point &lt;digit_string&gt; [{user.css_unit}] , imp:"{number_string}.{digit_string}{css_unit or ''}"
		</p><p>rule: (value | state) {user.css_global_value} , imp:"{css_global_value}"</p><p>rule: value &lt;user.text&gt; , imp:user.insert_formatted(text, "DASH_SEPARATED")</p><p>rule: variable &lt;user.text&gt; , imp:name = user.formatted_text(text, "DASH_SEPARATED")
		insert("var(--{name})")
		</p><p>rule: op var , imp:user.insert_between("var(--", ")")</p><p>rule: at {user.css_at_rule} , imp:"@{css_at_rule} "</p><p>rule: unit {user.css_unit} , imp:insert(css_unit)</p><p>rule: [value] current color , imp:"currentColor"</p><p>rule: op important , imp:" !important"</p><h2>java</h2><p>rule: state var , imp:"var "</p><p>rule: boxed [type] {user.java_boxed_type} , imp:insert(user.java_boxed_type + " ")</p><p>rule: generic [type] {user.java_generic_data_structure} , imp:user.insert_between(java_generic_data_structure + "&lt;", "&gt;")
		
		# Arrays</p><p>rule: type {user.code_type} array , imp:insert(user.code_type)
		user.code_operator_subscript()
		</p><p>rule: [state] {user.java_modifier} , imp:insert(user.java_modifier + " ")</p><p>rule: op array , imp:user.code_operator_subscript()</p><p>rule: op new , imp:insert("new ")</p><p style="page-break-after: always;">&nbsp;</p><h2>javascript</h2><p>rule: (op | is) strict equal , imp:" === "</p><p>rule: (op | is) strict not equal , imp:" !== "</p><p>rule: op null else , imp:" ?? "</p><p>rule: state const , imp:"const "</p><p>rule: state let , imp:"let "</p><p>rule: state var , imp:"var "</p><p>rule: state export , imp:"export "</p><p>rule: state async , imp:"async "</p><p>rule: state await , imp:"await "</p><p>rule: dot {user.code_common_member_function} , imp:user.insert_between(".{code_common_member_function}(", ")")
		</p><p>rule: state map , imp:app.notify('ERROR: Command deprecated; please use "dot map"')</p><p>rule: state filter , imp:app.notify('ERROR: Command deprecated; please use "dot filter"')</p><p>rule: state reduce , imp:app.notify('ERROR: Command deprecated; please use "dot reduce"')</p><p>rule: state spread , imp:"..."</p><p>rule: from import , imp:user.insert_between(' from  "', '"')</p><h2>lua</h2><p>rule: state local , imp:"local"</p><p>rule: state end , imp:"end"</p><p>rule: state then , imp:"then"</p><p>rule: state repeat , imp:"repeat"</p><p>rule: state until , imp:"until"</p><p>rule: state return (null | nil) , imp:"return nil"</p><p>rule: state return true , imp:"return true"</p><p>rule: state return false , imp:"return false"</p><p>rule: state return table , imp:user.insert_between("return {", "}")</p><p>rule: state append string , imp:" .. "</p><p>rule: state label &lt;user.text&gt; , imp:insert("::")
		user.insert_formatted(text, "snake")
		insert("::")
		</p><p>rule: require &lt;user.code_libraries&gt; , imp:user.code_insert_library("", code_libraries)
		key(end enter)
		</p><p>rule: state (variable | var) [&lt;user.text&gt;] [over] , imp:user.code_public_variable_formatter(text)</p><p>rule: state local (variable | var) [&lt;user.text&gt;] [over] , imp:insert("local ")
		user.code_private_variable_formatter(text)
		
		# for built in object methods, ex: foo:gsub()</p><p>rule: method &lt;user.text&gt; , imp:insert(":")
		user.code_public_function_formatter(text)
		insert("()")
		edit.left()
		</p><p>rule: self dot , imp:"self."</p><p>rule: index &lt;user.word&gt; , imp:'["{word}"]'</p><p>rule: index (var | variable) &lt;user.text&gt; , imp:var = user.formatted_text(text, "snake")
		insert("[{var}]")
		</p><p>rule: state return dick , imp:user.insert_between("return {", "}")</p><p style="page-break-after: always;">&nbsp;</p><h2>stylua</h2><p>rule: lint ignore , imp:"-- stylua: ignore"</p><p>rule: lint ignore start , imp:"-- stylua: ignore start"</p><p>rule: lint ignore end , imp:"-- stylua: ignore end"</p><h2>markdown</h2><p>rule: (level | heading | header) one , imp:edit.line_start()
		"# "</p><p>rule: (level | heading | header) two , imp:edit.line_start()
		"## "</p><p>rule: (level | heading | header) three , imp:edit.line_start()
		"### "</p><p>rule: (level | heading | header) four , imp:edit.line_start()
		"#### "</p><p>rule: (level | heading | header) five , imp:edit.line_start()
		"##### "</p><p>rule: (level | heading | header) six , imp:edit.line_start()
		"###### "
		</p><p>rule: list [one] , imp:edit.line_start()
		"- "</p><p>rule: list two , imp:edit.line_start()
		"    - "</p><p>rule: list three , imp:edit.line_start()
		"        - "</p><p>rule: list four , imp:edit.line_start()
		"            - "</p><p>rule: list five , imp:edit.line_start()
		"                - "</p><p>rule: list six , imp:edit.line_start()
		"                    - "
		</p><p>rule: {user.markdown_code_block_language} block , imp:user.insert_snippet("```{markdown_code_block_language}\n$0\n```")
		</p><p>rule: link , imp:"[]()"
		key(left:3)</p><h2>php</h2><p>rule: (op | is) loosely equal , imp:" == "</p><p>rule: (op | is) loosely not equal , imp:" != "</p><p>rule: state try , imp:"try {\n"</p><p>rule: state catch , imp:"catch (\\Throwable $exception) {\n"</p><p>rule: var &lt;phrase&gt; [over] , imp:insert("$")
		insert(user.formatted_text(phrase, "PRIVATE_CAMEL_CASE"))</p><p style="page-break-after: always;">&nbsp;</p><h2>proto</h2><p>rule: block , imp:user.code_block()</p><p>rule: state message , imp:"message "</p><p>rule: state package , imp:"package "</p><p>rule: state reserved , imp:"reserved "</p><p>rule: state enum , imp:"enum "</p><p>rule: op equals , imp:" = "</p><p>rule: state import , imp:"import "</p><p>rule: state import public , imp:"import public "</p><p>rule: state option , imp:"option "</p><p>rule: state repeated , imp:"repeated "</p><p>rule: type {user.code_type} , imp:"{code_type}"</p><p>rule: repeated type {user.code_type} , imp:"repeated {code_type}"</p><h2>python</h2><p>rule: dunder in it , imp:"__init__"</p><p>rule: state (def | deaf | deft) , imp:"def "</p><p>rule: state try , imp:"try:\n"</p><p>rule: state except , imp:"except "</p><p>rule: state raise , imp:"raise "</p><p>rule: self taught , imp:"self."</p><p>rule: pie test , imp:"pytest"</p><p>rule: state past , imp:"pass"</p><p>rule: [state] raise {user.python_exception} , imp:user.insert_between("raise {python_exception}(", ")")</p><p>rule: [state] except {user.python_exception} , imp:"except {python_exception}:"</p><p>rule: dock string , imp:user.code_comment_documentation()</p><p>rule: dock {user.python_docstring_fields} , imp:insert("{python_docstring_fields}")
		edit.left()</p><p>rule: dock type {user.code_type} , imp:user.insert_between(":type ", ": {code_type}")</p><p>rule: dock returns type {user.code_type} , imp:user.insert_between(":rtype ", ": {code_type}")</p><p>rule: toggle imports , imp:user.code_toggle_libraries()</p><p>rule: import &lt;user.code_libraries&gt; , imp:user.code_insert_library(code_libraries, "")
		key(end enter)
		</p><p>rule: from import , imp:user.insert_between("from ", " import ")</p><p style="page-break-after: always;">&nbsp;</p><h2>r</h2><p>rule: (op | is) in , imp:" %in% "</p><p>rule: toggle library , imp:user.code_toggle_libraries()</p><p>rule: library &lt;user.code_libraries&gt; , imp:user.code_insert_library(code_libraries, "")
		key(end enter)
		
		# R specific commands</p><p>rule: (chain | pipe that) , imp:key(end)
		" %&gt;%"
		key(enter)</p><p>rule: state na , imp:insert("NA")</p><p>rule: function define &lt;user.text&gt; , imp:user.code_private_function(text)</p><p>rule: named arg {user.code_parameter_name} , imp:user.code_insert_named_argument(code_parameter_name)</p><h2>ruby</h2><p>rule: args pipe , imp:user.insert_between("|", "|")</p><p>rule: dock string , imp:user.code_comment_documentation()</p><p>rule: state end , imp:"end"</p><p>rule: state begin , imp:"begin"</p><p>rule: state rescue , imp:"rescue "</p><p>rule: state module , imp:"module "</p><p>rule: instance &lt;user.text&gt; , imp:insert("@")
		user.code_public_variable_formatter(text)</p><h2>rust</h2><p>rule: state unsafe , imp:"unsafe "</p><p>rule: unsafe block , imp:user.code_state_unsafe()</p><p>rule: state (struct | structure) &lt;user.text&gt; , imp:insert("struct ")
		insert(user.formatted_text(text, "PUBLIC_CAMEL_CASE"))
		</p><p>rule: state enum &lt;user.text&gt; , imp:insert("enum ")
		insert(user.formatted_text(text, "PUBLIC_CAMEL_CASE"))
		</p><p>rule: toggle use , imp:user.code_toggle_libraries()</p><p>rule: borrow , imp:"&"</p><p>rule: borrow mutable , imp:"&mut "</p><p>rule: state (a sink | async | asynchronous) , imp:"async "</p><p>rule: state (pub | public) , imp:"pub "</p><p>rule: state (pub | public) crate , imp:"pub(crate) "</p><p>rule: state (dyn | dynamic) , imp:"dyn "</p><p>rule: state constant , imp:"const "</p><p>rule: state (funk | func | function) , imp:"fn "</p><p>rule: state (imp | implements) , imp:"impl "</p><p>rule: state let mute , imp:"let mut "</p><p>rule: state let , imp:"let "</p><p>rule: state (mute | mutable) , imp:"mut "</p><p>rule: state (mod | module) , imp:"mod "</p><p>rule: state ref (mute | mutable) , imp:"ref mut "</p><p>rule: state ref , imp:"ref "</p><p>rule: state trait , imp:"trait "</p><p>rule: state match , imp:user.code_state_switch()</p><p>rule: state (some | sum) , imp:"Some"</p><p>rule: state static , imp:"static "</p><p>rule: self taught , imp:"self."</p><p>rule: state use , imp:user.code_import()</p><p>rule: use &lt;user.code_libraries&gt; , imp:user.code_insert_library(code_libraries, "")
		key(; enter)
		
		## specialist flow control</p><p>rule: state if let some , imp:user.insert_between("if let Some(", ")")</p><p>rule: state if let (ok | okay) , imp:user.insert_between("if let Ok(", ")")</p><p>rule: state if let error , imp:user.insert_between("if let Err(", ")")</p><p>rule: is some , imp:user.code_insert_is_not_null()</p><p>rule: implement (struct | structure) , imp:user.code_state_implements()</p><p>rule: is implemented trait {user.code_trait} , imp:": impl {code_trait}"</p><p>rule: is implemented trait , imp:": impl "</p><p>rule: returns implemented trait {user.code_trait} , imp:" -&gt; impl {code_trait}"</p><p>rule: returns implemented trait , imp:" -&gt; impl "</p><p>rule: trait {user.code_trait} , imp:insert("{code_trait}")</p><p>rule: implemented trait {user.code_trait} , imp:insert("impl {code_trait}")</p><p>rule: dynamic trait {user.code_trait} , imp:insert("dyn {code_trait}")</p><p>rule: macro {user.code_macros} , imp:user.code_insert_macro(code_macros, "")</p><p>rule: macro wrap {user.code_macros} , imp:user.code_insert_macro(code_macros, edit.selected_text())
		
		## rust specific document comments</p><p>rule: block dock comment , imp:user.code_comment_documentation_block()</p><p>rule: inner dock comment , imp:user.code_comment_documentation_inner()</p><p>rule: inner block dock comment , imp:user.code_comment_documentation_block_inner()</p><p style="page-break-after: always;">&nbsp;</p><h2>scala</h2><p>rule: state {user.scala_modifier} , imp:insert("{user.scala_modifier} ")</p><p>rule: state {user.scala_keyword} , imp:insert("{scala_keyword} ")</p><p>rule: op right arrow , imp:" -&gt; "</p><p>rule: op left arrow , imp:" &lt;- "</p><p>rule: op plus plus , imp:" ++ "</p><p>rule: op subtype , imp:" &lt;: "</p><p>rule: state match , imp:user.code_state_switch()</p><p>rule: block string , imp:insert('""""""')
		key("left left left")</p><h2>sql</h2><p>rule: select , imp:"SELECT "</p><p>rule: distinct , imp:"DISTINCT "</p><p>rule: from , imp:"FROM "</p><p>rule: select star from , imp:"SELECT *\nFROM "</p><p>rule: where , imp:"WHERE "</p><p>rule: order by , imp:"ORDER BY "</p><p>rule: group by , imp:"GROUP BY "</p><p>rule: having , imp:"HAVING "</p><p>rule: descending , imp:" DESC"</p><p>rule: ascending , imp:" ASC"</p><p>rule: dot i d , imp:".id"</p><p>rule: inner join , imp:user.insert_between("INNER JOIN ", " ON ")</p><p>rule: inner join using , imp:user.insert_between("INNER JOIN ", " USING ")</p><p>rule: left outer join , imp:user.insert_between("LEFT OUTER JOIN ", " ON ")</p><p>rule: right outer join , imp:user.insert_between("RIGHT OUTER JOIN ", " ON ")</p><p>rule: with , imp:key(enter up)
		"WITH  AS ("
		key(enter tab)
		"SELECT "
		key(enter shift-tab)
		edit.extend_line_end()
		edit.delete()
		") "
		key(delete up:2 right:3)
		</p><p>rule: column , imp:key(return)
		", "
		</p><p>rule: count , imp:user.code_insert_function("Count", "")</p><p>rule: date , imp:user.insert_between("DATE '", "'")</p><p style="page-break-after: always;">&nbsp;</p><h2>comment block</h2><p>rule: block comment , imp:user.code_comment_block()</p><p>rule: block comment line , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		edit.line_start()
		user.code_comment_block_prefix()
		key(space)
		edit.line_end()
		key(space)
		user.code_comment_block_suffix()
		#adds comment to the start of the line</p><p>rule: block comment line &lt;user.text&gt; over , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		edit.line_start()
		user.code_comment_block()
		insert(user.text)</p><p>rule: block comment &lt;user.text&gt; over , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		user.code_comment_block()
		insert(user.text)</p><p>rule: block comment &lt;user.text&gt; , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		user.code_comment_block()
		insert(user.text)</p><p>rule: (line | inline) block comment &lt;user.text&gt; over , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		edit.line_end()
		user.code_comment_block_prefix()
		key(space)
		insert(user.text)
		key(space)
		user.code_comment_block_suffix()</p><p>rule: (line | inline) block comment &lt;user.text&gt; , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		edit.line_end()
		user.code_comment_block_prefix()
		key(space)
		insert(user.text)
		key(space)
		user.code_comment_block_suffix()</p><p>rule: open block comment , imp:user.code_comment_block_prefix()</p><p>rule: close block comment , imp:user.code_comment_block_suffix()</p><h2>comment documentation</h2><p>rule: dock comment , imp:user.code_comment_documentation()</p><h2>comment line</h2><p>rule: comment , imp:user.code_comment_line_prefix()</p><p>rule: comment line , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		edit.line_start()
		user.code_comment_line_prefix()
		#adds comment to the start of the line</p><p>rule: comment line &lt;user.text&gt; over , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		edit.line_start()
		user.code_comment_line_prefix()
		insert(user.text)
		insert(" ")</p><p>rule: comment &lt;user.text&gt; over , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		user.code_comment_line_prefix()
		insert(user.text)</p><p>rule: comment &lt;user.text&gt; , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		user.code_comment_line_prefix()
		insert(user.text)</p><p>rule: (line | inline) comment &lt;user.text&gt; over , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		edit.line_end()
		user.code_comment_line_prefix()
		insert(user.text)</p><p>rule: (line | inline) comment &lt;user.text&gt; , imp:#todo: this should probably be a single function once
		#.talon supports implementing actions with parameters?
		edit.line_end()
		user.code_comment_line_prefix()
		insert(user.text)</p><h2>data bool</h2><p>rule: state true , imp:user.code_insert_true()</p><p>rule: state false , imp:user.code_insert_false()</p><h2>data null</h2><p>rule: state (no | none | nil | null) , imp:user.code_insert_null()</p><p>rule: is not (none | null) , imp:user.code_insert_is_not_null()</p><p>rule: is (none | null) , imp:user.code_insert_is_null()</p><p style="page-break-after: always;">&nbsp;</p><h2>functions</h2><p>rule: {user.code_function_modifier}* funky &lt;user.text&gt; , imp:user.code_modified_function(code_function_modifier_list or 0, text)
		
		# for annotating function parameters</p><p>rule: is type &lt;user.code_type&gt; , imp:user.code_insert_type_annotation(code_type)</p><p>rule: returns [type] &lt;user.code_type&gt; , imp:user.code_insert_return_type(code_type)</p><p>rule: type &lt;user.code_type&gt; , imp:insert(code_type)</p><h2>functions common</h2><p>rule: toggle funk , imp:user.code_toggle_functions()</p><p>rule: funk &lt;user.code_common_function&gt; , imp:user.code_insert_function(code_common_function, "")</p><p>rule: funk cell &lt;number&gt; , imp:user.code_select_function(number - 1, "")</p><p>rule: funk wrap &lt;user.code_common_function&gt; , imp:user.code_insert_function(code_common_function, edit.selected_text())</p><p>rule: funk wrap &lt;number&gt; , imp:user.code_select_function(number - 1, edit.selected_text())</p><h2>functions common gui active</h2><p>rule: toggle funk , imp:user.code_toggle_functions()</p><h2>imperative</h2><p>rule: block , imp:user.code_block()</p><p>rule: state if , imp:user.code_state_if()</p><p>rule: state else if , imp:user.code_state_else_if()</p><p>rule: state else , imp:user.code_state_else()</p><p>rule: state while , imp:user.code_state_while()</p><p>rule: state loop , imp:user.code_state_infinite_loop()</p><p>rule: state for , imp:user.code_state_for()</p><p>rule: state for in , imp:user.code_state_for_each()</p><p>rule: state switch , imp:user.code_state_switch()</p><p>rule: state case , imp:user.code_state_case()</p><p>rule: state do , imp:user.code_state_do()</p><p>rule: state goto , imp:user.code_state_go_to()</p><p>rule: state return , imp:user.code_state_return()</p><p>rule: state break , imp:user.code_break()</p><p>rule: state (continue | next) , imp:user.code_next()</p><p style="page-break-after: always;">&nbsp;</p><h2>keywords</h2><p>rule: keyword (&lt;user.code_keyword&gt;+) , imp:user.code_keyword(code_keyword_list)</p><h2>libraries</h2><p>rule: state import , imp:user.code_import()</p><h2>library gui open</h2><p>rule: toggle libraries close , imp:user.code_toggle_libraries()</p><h2>object oriented</h2><p>rule: self dot , imp:user.code_self()
		user.code_operator_object_accessor()
		</p><p>rule: state self , imp:user.code_self()</p><p>rule: state class , imp:user.code_define_class()</p><h2>operators array</h2><p>rule: op subscript , imp:user.code_operator_subscript()</p><h2>operators assignment</h2><p>rule: op (equals | assign) , imp:user.code_operator_assignment()</p><p>rule: op or equals , imp:user.code_or_operator_assignment()</p><p>rule: op (minus | subtract) equals , imp:user.code_operator_subtraction_assignment()</p><p>rule: op (plus | add) equals , imp:user.code_operator_addition_assignment()</p><p>rule: op (times | multiply) equals , imp:user.code_operator_multiplication_assignment()</p><p>rule: op divide equals , imp:user.code_operator_division_assignment()</p><p>rule: op mod equals , imp:user.code_operator_modulo_assignment()</p><p>rule: [op] increment , imp:user.code_operator_increment()</p><p>rule: [op] bit [wise] and equals , imp:user.code_operator_bitwise_and_assignment()</p><p>rule: [op] bit [wise] or equals , imp:user.code_operator_bitwise_or_assignment()</p><p>rule: (op | logical | bitwise) (ex | exclusive) or equals , imp:user.code_operator_bitwise_exclusive_or_assignment()</p><p>rule: [(op | logical | bitwise)] (left shift | shift left) equals , imp:user.code_operator_bitwise_left_shift_assignment()</p><p>rule: [(op | logical | bitwise)] (right shift | shift right) equals , imp:user.code_operator_bitwise_right_shift_assignment()</p><h2>operators bitwise</h2><p>rule: [op] bitwise and , imp:user.code_operator_bitwise_and()</p><p>rule: [op] bitwise or , imp:user.code_operator_bitwise_or()</p><p>rule: (op | logical | bitwise) (ex | exclusive) or , imp:user.code_operator_bitwise_exclusive_or()</p><p>rule: (op | logical | bitwise) (left shift | shift left) , imp:user.code_operator_bitwise_left_shift()</p><p>rule: (op | logical | bitwise) (right shift | shift right) , imp:user.code_operator_bitwise_right_shift()</p><p style="page-break-after: always;">&nbsp;</p><h2>operators lambda</h2><p>rule: op lambda , imp:user.code_operator_lambda()</p><h2>operators math</h2><p>rule: op (minus | subtract) , imp:user.code_operator_subtraction()</p><p>rule: op (plus | add) , imp:user.code_operator_addition()</p><p>rule: op (times | multiply) , imp:user.code_operator_multiplication()</p><p>rule: op divide , imp:user.code_operator_division()</p><p>rule: op mod , imp:user.code_operator_modulo()</p><p>rule: (op (power | exponent) | to the power [of]) , imp:user.code_operator_exponent()</p><p>rule: (op | is) equal , imp:user.code_operator_equal()</p><p>rule: (op | is) not equal , imp:user.code_operator_not_equal()</p><p>rule: (op | is) (greater | more) , imp:user.code_operator_greater_than()</p><p>rule: (op | is) (less | below) [than] , imp:user.code_operator_less_than()</p><p>rule: (op | is) greater [than] or equal , imp:user.code_operator_greater_than_or_equal_to()</p><p>rule: (op | is) less [than] or equal , imp:user.code_operator_less_than_or_equal_to()</p><p>rule: (op | logical) and , imp:user.code_operator_and()</p><p>rule: (op | logical) or , imp:user.code_operator_or()</p><p>rule: (op | is) in , imp:user.code_operator_in()</p><p>rule: (op | is) not in , imp:user.code_operator_not_in()</p><p>rule: (op | pad) colon , imp:" : "</p><h2>operators pointer</h2><p>rule: op dereference , imp:user.code_operator_indirection()</p><p>rule: op address of , imp:user.code_operator_address_of()</p><p>rule: op arrow , imp:user.code_operator_structure_dereference()</p><p style="page-break-after: always;">&nbsp;</p><h2>talon</h2><p>rule: dot talon , imp:insert(".talon")</p><p>rule: action block , imp:user.insert_between("action(", "):")</p><p>rule: setting block , imp:insert("settings():\n\t")</p><p>rule: setting {user.talon_settings} , imp:user.paste("{talon_settings} = ")</p><p>rule: win require , imp:insert("os: windows\n")</p><p>rule: mac require , imp:insert("os: mac\n")</p><p>rule: linux require , imp:insert("os: linux\n")</p><p>rule: title require , imp:insert("win.title: ")</p><p>rule: application [require] [{user.talon_apps}] , imp:app = talon_apps or ""
		user.paste("app: {app}")</p><p>rule: mode require [{user.talon_modes}] , imp:mode = talon_modes or ""
		user.paste("mode: {mode}")</p><p>rule: tag require [{user.talon_tags}] , imp:tag = talon_tags or ""
		user.paste("tag: {tag}")</p><p>rule: tag set [{user.talon_tags}] , imp:tag = talon_tags or ""
		user.paste("tag(): {tag}")</p><p>rule: host require , imp:hostname = user.talon_get_hostname()
		user.paste("hostname: {hostname}\n")
		# requires user.talon_populate_lists tag. do not use with dragon</p><p>rule: list {user.talon_lists} , imp:"{{{talon_lists}}}"</p><p>rule: capture {user.talon_captures} , imp:"&lt;{talon_captures}&gt;"</p><p>rule: key &lt;user.keys&gt; over , imp:"{keys}"</p><p>rule: key &lt;user.modifiers&gt; over , imp:"{modifiers}"</p><p>rule: funk {user.talon_actions} , imp:user.code_insert_function(talon_actions, edit.selected_text())</p><p>rule: funk cell &lt;number&gt; , imp:user.code_select_function(number - 1, "")</p><p>rule: funk wrap &lt;user.code_common_function&gt; , imp:user.code_insert_function(code_common_function, edit.selected_text())</p><p>rule: funk wrap &lt;number&gt; , imp:user.code_select_function(number - 1, edit.selected_text())</p><p style="page-break-after: always;">&nbsp;</p><h2>terraform</h2><p>rule: block , imp:user.code_block()</p><p>rule: state {user.terraform_module_block} , imp:user.code_terraform_module_block(user.terraform_module_block)
		</p><p>rule: resource &lt;user.text&gt; , imp:user.code_terraform_resource(text)</p><p>rule: data [source] &lt;user.text&gt; , imp:user.code_terraform_data_source(text)</p><p>rule: [state] prop {user.terraform_common_property} , imp:insert(user.terraform_common_property)
		user.code_operator_assignment()
		</p><p>rule: type {user.code_type} , imp:insert("{code_type}")</p><h2>typescript</h2><p>rule: type union [&lt;user.code_type&gt;] , imp:" | {code_type or ''}"</p><p>rule: type intersect [&lt;user.code_type&gt;] , imp:" & {code_type or ''}"</p><p>rule: state type , imp:user.insert_between("type ", " = ")</p><p>rule: as const , imp:" as const"</p><h2>vimscript</h2><p>rule: assign [&lt;user.vimscript_scope&gt;] (variable | var) [&lt;user.text&gt;] [over] , imp:insert("let ")
		insert(vimscript_scope or "")
		user.code_private_variable_formatter(text)
		</p><p>rule: [&lt;user.vimscript_scope&gt;] (variable | var) [&lt;user.text&gt;] [over] , imp:insert(vimscript_scope or "")
		user.code_private_variable_formatter(text)
		
		# see lang/vimscript/vimscript.py for list</p><p>rule: &lt;user.vimscript_functions&gt; , imp:insert("{vimscript_functions} ")</p><p>rule: state command , imp:"command! "</p><p>rule: state end if , imp:"endif"</p><p>rule: state end for , imp:"endfor"</p><p>rule: state end while , imp:"endwhile"</p><p>rule: state end function , imp:"endfunction"</p><p>rule: state continue , imp:"continue"</p><h2>cancel</h2><p>rule: cancel cancel , imp:skip()</p><p>rule: ignore [&lt;phrase&gt;] , imp:app.notify("Command ignored")</p><p style="page-break-after: always;">&nbsp;</p><h2>command history</h2><p>rule: command history , imp:user.history_toggle()</p><p>rule: command history close , imp:user.history_disable()</p><p>rule: command history clear , imp:user.history_clear()</p><p>rule: command history less , imp:user.history_less()</p><p>rule: command history more , imp:user.history_more()</p><h2>datetimeinsert</h2><p>rule: date insert , imp:insert(user.time_format("%Y-%m-%d"))</p><p>rule: date insert UTC , imp:insert(user.time_format_utc("%Y-%m-%d"))</p><p>rule: timestamp insert , imp:insert(user.time_format("%Y-%m-%d %H:%M:%S"))</p><p>rule: timestamp insert high resolution , imp:insert(user.time_format("%Y-%m-%d %H:%M:%S.%f"))</p><p>rule: timestamp insert UTC , imp:insert(user.time_format_utc("%Y-%m-%d %H:%M:%S"))</p><p>rule: timestamp insert UTC high resolution , imp:insert(user.time_format_utc("%Y-%m-%d %H:%M:%S.%f"))</p><h2>desktops</h2><p>rule: desk &lt;number_small&gt; , imp:user.desktop(number_small)</p><p>rule: desk next , imp:user.desktop_next()</p><p>rule: desk last , imp:user.desktop_last()</p><p>rule: desk show , imp:user.desktop_show()</p><p>rule: window move desk &lt;number&gt; , imp:user.window_move_desktop(number)</p><p>rule: window move desk left , imp:user.window_move_desktop_left()</p><p>rule: window move desk right , imp:user.window_move_desktop_right()</p><h2>draft editor</h2><p>rule: draft this , imp:user.draft_editor_open()</p><p>rule: draft all , imp:edit.select_all()
		user.draft_editor_open()
		</p><p>rule: draft line , imp:edit.select_line()
		user.draft_editor_open()
		</p><p>rule: draft top , imp:edit.extend_file_start()
		user.draft_editor_open()
		</p><p>rule: draft bottom , imp:edit.extend_file_end()
		user.draft_editor_open()
		</p><p>rule: draft submit , imp:user.draft_editor_paste_last()</p><p style="page-break-after: always;">&nbsp;</p><h2>draft editor open</h2><p>rule: draft submit , imp:user.draft_editor_submit()</p><p>rule: draft discard , imp:user.draft_editor_discard()</p><h2>dropdown</h2><p>rule: drop down &lt;number_small&gt; , imp:key("down:{number_small-1} enter")</p><p>rule: drop down up &lt;number_small&gt; , imp:key("up:{number_small} enter")</p><h2>macro</h2><p>rule: macro record , imp:user.macro_record()</p><p>rule: macro stop , imp:user.macro_stop()</p><p>rule: macro play [{user.saved_macros}] , imp:user.macro_play(saved_macros or "")</p><p>rule: macro copy [{user.saved_macros}] , imp:user.macro_copy(saved_macros or "")</p><p>rule: macro copy as &lt;user.text&gt; , imp:user.macro_copy(text)</p><p>rule: macro save as &lt;user.text&gt; , imp:user.macro_save(text)</p><p>rule: macro list , imp:user.macro_list()</p><p>rule: macro list close , imp:user.macro_list_close()</p><h2>media</h2><p>rule: volume up , imp:key(volup)</p><p>rule: volume down , imp:key(voldown)</p><p>rule: set volume &lt;number&gt; , imp:user.media_set_volume(number)</p><p>rule: (volume | media) mute , imp:key(mute)</p><p>rule: [media] play next , imp:key(next)</p><p>rule: [media] play previous , imp:key(prev)</p><p>rule: media (play | pause) , imp:user.play_pause()</p><h2>microphone selection</h2><p>rule: microphone show , imp:user.microphone_selection_toggle()</p><p>rule: microphone close , imp:user.microphone_selection_hide()</p><p>rule: microphone pick &lt;number_small&gt; , imp:user.microphone_select(number_small)</p><p style="page-break-after: always;">&nbsp;</p><h2>mouse</h2><p>rule: control mouse , imp:tracking.control_toggle()</p><p>rule: control off , imp:user.mouse_sleep()</p><p>rule: zoom mouse , imp:tracking.control_zoom_toggle()</p><p>rule: camera overlay , imp:tracking.control_debug_toggle()</p><p>rule: run calibration , imp:tracking.calibrate()</p><p>rule: touch , imp:# close zoom if open
		user.zoom_close()
		mouse_click(0)
		# close the mouse grid if open
		user.grid_close()
		# End any open drags
		# Touch automatically ends left drags so this is for right drags specifically
		user.mouse_drag_end()
		</p><p>rule: righty , imp:# close zoom if open
		user.zoom_close()
		mouse_click(1)
		# close the mouse grid if open
		user.grid_close()
		</p><p>rule: mid click , imp:# close zoom if open
		user.zoom_close()
		mouse_click(2)
		# close the mouse grid
		user.grid_close()
		
		#see keys.py for modifiers.
		#defaults
		#command
		#control
		#option = alt
		#shift
		#super = windows key</p><p>rule: &lt;user.modifiers&gt; touch , imp:# close zoom if open
		user.zoom_close()
		key("{modifiers}:down")
		mouse_click(0)
		key("{modifiers}:up")
		# close the mouse grid
		user.grid_close()</p><p>rule: &lt;user.modifiers&gt; righty , imp:# close zoom if open
		user.zoom_close()
		key("{modifiers}:down")
		mouse_click(1)
		key("{modifiers}:up")
		# close the mouse grid
		user.grid_close()</p><p>rule: (dub click | duke) , imp:# close zoom if open
		user.zoom_close()
		mouse_click()
		mouse_click()
		# close the mouse grid
		user.grid_close()</p><p>rule: (trip click | trip lick) , imp:# close zoom if open
		user.zoom_close()
		mouse_click()
		mouse_click()
		mouse_click()
		# close the mouse grid
		user.grid_close()</p><p>rule: left drag | drag | drag start , imp:# close zoom if open
		user.zoom_close()
		user.mouse_drag(0)
		# close the mouse grid
		user.grid_close()</p><p>rule: right drag | righty drag , imp:# close zoom if open
		user.zoom_close()
		user.mouse_drag(1)
		# close the mouse grid
		user.grid_close()</p><p>rule: end drag | drag end , imp:user.mouse_drag_end()</p><p>rule: wheel down , imp:user.mouse_scroll_down()</p><p>rule: wheel down here , imp:user.mouse_move_center_active_window()
		user.mouse_scroll_down()</p><p>rule: wheel tiny [down] , imp:user.mouse_scroll_down(0.2)</p><p>rule: wheel tiny [down] here , imp:user.mouse_move_center_active_window()
		user.mouse_scroll_down(0.2)</p><p>rule: wheel downer , imp:user.mouse_scroll_down_continuous()</p><p>rule: wheel downer here , imp:user.mouse_move_center_active_window()
		user.mouse_scroll_down_continuous()</p><p>rule: wheel up , imp:user.mouse_scroll_up()</p><p>rule: wheel up here , imp:user.mouse_move_center_active_window()
		user.mouse_scroll_up()</p><p>rule: wheel tiny up , imp:user.mouse_scroll_up(0.2)</p><p>rule: wheel tiny up here , imp:user.mouse_move_center_active_window()
		user.mouse_scroll_up(0.2)</p><p>rule: wheel upper , imp:user.mouse_scroll_up_continuous()</p><p>rule: wheel upper here , imp:user.mouse_move_center_active_window()
		user.mouse_scroll_up_continuous()</p><p>rule: wheel gaze , imp:user.mouse_gaze_scroll()</p><p>rule: wheel gaze here , imp:user.mouse_move_center_active_window()
		user.mouse_gaze_scroll()</p><p>rule: wheel stop , imp:user.mouse_scroll_stop()</p><p>rule: wheel stop here , imp:user.mouse_move_center_active_window()
		user.mouse_scroll_stop()</p><p>rule: wheel left , imp:user.mouse_scroll_left()</p><p>rule: wheel left here , imp:user.mouse_move_center_active_window()
		user.mouse_scroll_left()</p><p>rule: wheel tiny left , imp:user.mouse_scroll_left(0.5)</p><p>rule: wheel tiny left here , imp:user.mouse_move_center_active_window()
		user.mouse_scroll_left(0.5)</p><p>rule: wheel right , imp:user.mouse_scroll_right()</p><p>rule: wheel right here , imp:user.mouse_move_center_active_window()
		user.mouse_scroll_right()</p><p>rule: wheel tiny right , imp:user.mouse_scroll_right(0.5)</p><p>rule: wheel tiny right here , imp:user.mouse_move_center_active_window()
		user.mouse_scroll_right(0.5)</p><p>rule: copy mouse position , imp:user.copy_mouse_position()</p><p>rule: curse no , imp:# Command added 2021-12-13, can remove after 2022-06-01
		app.notify("Please activate the user.mouse_cursor_commands_enable tag to enable this command")
		</p><p>rule: mouse hiss up , imp:user.hiss_scroll_up()</p><p>rule: mouse hiss down , imp:user.hiss_scroll_down()</p><p style="page-break-after: always;">&nbsp;</p><h2>mouse cursor</h2><p>rule: curse yes , imp:user.mouse_show_cursor()</p><p>rule: curse no , imp:user.mouse_hide_cursor()</p><h2>repeater</h2><p>rule: &lt;user.ordinals&gt; , imp:core.repeat_command(ordinals - 1)</p><p>rule: &lt;number_small&gt; times , imp:core.repeat_command(number_small - 1)</p><p>rule: (repeat that | twice) , imp:core.repeat_command(1)</p><p>rule: repeat that &lt;number_small&gt; [times] , imp:core.repeat_command(number_small)</p><p>rule: (repeat phrase | again) [&lt;number_small&gt; times] , imp:core.repeat_partial_phrase(number_small or 1)</p><h2>screenshot</h2><p>rule: grab screen , imp:user.screenshot()</p><p>rule: grab screen &lt;number_small&gt; , imp:user.screenshot(number_small)</p><p>rule: grab window , imp:user.screenshot_window()</p><p>rule: grab selection , imp:user.screenshot_selection()</p><p>rule: grab selection clip , imp:user.screenshot_selection_clip()</p><p>rule: grab settings , imp:user.screenshot_settings()</p><p>rule: grab screen clip , imp:user.screenshot_clipboard()</p><p>rule: grab screen &lt;number_small&gt; clip , imp:user.screenshot_clipboard(number_small)</p><p>rule: grab window clip , imp:user.screenshot_window_clipboard()</p><h2>symbols</h2><p>rule: new line , imp:"\n"</p><p>rule: double dash , imp:"--"</p><p>rule: triple quote , imp:"'''"</p><p>rule: (triple grave | triple back tick | gravy) , imp:insert("```")</p><p>rule: (dot dot | dotdot) , imp:".."</p><p>rule: ellipsis , imp:"..."</p><p>rule: (comma and | spamma) , imp:", "</p><p>rule: arrow , imp:"-&gt;"</p><p>rule: dub arrow , imp:"=&gt;"</p><p>rule: empty dub string , imp:user.insert_between('"', '"')</p><p>rule: empty escaped (dub string | dub quotes) , imp:user.insert_between('\\"', '\\"')</p><p>rule: empty string , imp:user.insert_between("'", "'")</p><p>rule: empty escaped string , imp:user.insert_between("\\'", "\\'")</p><p>rule: (inside parens | args) , imp:user.insert_between("(", ")")</p><p>rule: inside (squares | brackets | square brackets | list) , imp:user.insert_between("[", "]")</p><p>rule: inside (braces | curly brackets) , imp:user.insert_between("{", "}")</p><p>rule: inside percent , imp:user.insert_between("%", "%")</p><p>rule: inside (quotes | string) , imp:user.insert_between("'", "'")</p><p>rule: inside (double quotes | dub quotes) , imp:user.insert_between('"', '"')</p><p>rule: inside (graves | back ticks) , imp:user.insert_between("`", "`")</p><p>rule: angle that , imp:text = edit.selected_text()
		user.paste("&lt;{text}&gt;")</p><p>rule: (square | bracket | square bracket) that , imp:text = edit.selected_text()
		user.paste("[{text}]")</p><p>rule: (brace | curly bracket) that , imp:text = edit.selected_text()
		user.paste("{{{text}}}")</p><p>rule: (parens | args) that , imp:text = edit.selected_text()
		user.paste("({text})")</p><p>rule: percent that , imp:text = edit.selected_text()
		user.paste("%{text}%")</p><p>rule: quote that , imp:text = edit.selected_text()
		user.paste("'{text}'")</p><p>rule: (double quote | dub quote) that , imp:text = edit.selected_text()
		user.paste('"{text}"')</p><p>rule: (grave | back tick) that , imp:text = edit.selected_text()
		user.paste("`{text}`")</p><p style="page-break-after: always;">&nbsp;</p><h2>draft global</h2><p>rule: draft show , imp:# Do this toggle so we can have focus when saying 'draft show'
		user.draft_hide()
		user.draft_show()
		</p><p>rule: draft show &lt;user.draft_window_position&gt; , imp:# Do this toggle so we can have focus when saying 'draft show'
		user.draft_hide()
		user.draft_show()
		user.draft_named_move(draft_window_position)
		</p><p>rule: draft show small , imp:# Do this toggle so we can have focus when saying 'draft show'
		user.draft_hide()
		user.draft_show()
		user.draft_resize(600, 200)
		</p><p>rule: draft show large , imp:# Do this toggle so we can have focus when saying 'draft show'
		user.draft_hide()
		user.draft_show()
		user.draft_resize(800, 500)
		</p><p>rule: draft empty , imp:user.draft_show("")</p><p>rule: draft edit , imp:text = edit.selected_text()
		key(backspace)
		user.draft_show(text)
		</p><p>rule: draft edit all , imp:edit.select_all()
		text = edit.selected_text()
		key(backspace)
		user.draft_show(text)</p><h2>draft window</h2><p>rule: replace &lt;user.draft_anchor&gt; with &lt;user.text&gt; , imp:user.draft_select("{draft_anchor}")
		result = user.formatted_text(text, "NOOP")
		insert(result)
		
		# Position cursor before word</p><p>rule: (pre | cursor | cursor before) &lt;user.draft_anchor&gt; , imp:user.draft_position_caret("{draft_anchor}")
		
		# Position cursor after word</p><p>rule: (post | cursor after) &lt;user.draft_anchor&gt; , imp:user.draft_position_caret("{draft_anchor}", 1)
		
		# Select a whole word</p><p>rule: (take | select) &lt;user.draft_anchor&gt; , imp:user.draft_select("{draft_anchor}")</p><p>rule: (take | select) &lt;user.draft_anchor&gt; (through | past) &lt;user.draft_anchor&gt; , imp:user.draft_select("{draft_anchor_1}", "{draft_anchor_2}")
		
		# Delete a word</p><p>rule: (change | chuck | clear) &lt;user.draft_anchor&gt; , imp:user.draft_select("{draft_anchor}", "", 1)
		key(backspace)
		
		# Delete a range of words</p><p>rule: (change | chuck | clear) &lt;user.draft_anchor&gt; (through | past) &lt;user.draft_anchor&gt; , imp:user.draft_select(draft_anchor_1, draft_anchor_2, 1)
		key(backspace)
		
		# reformat word</p><p>rule: &lt;user.formatters&gt; word &lt;user.draft_anchor&gt; , imp:user.draft_select("{draft_anchor}", "", 1)
		user.formatters_reformat_selection(user.formatters)
		
		# reformat range</p><p>rule: &lt;user.formatters&gt; &lt;user.draft_anchor&gt; (through | past) &lt;user.draft_anchor&gt; , imp:user.draft_select(draft_anchor_1, draft_anchor_2, 1)
		user.formatters_reformat_selection(user.formatters)</p><h2>draft window open</h2><p>rule: draft hide , imp:user.draft_hide()</p><p>rule: draft submit , imp:content = user.draft_get_text()
		user.draft_hide()
		insert(content)
		# user.paste may be somewhat faster, but seems to be unreliable on MacOSX, see
		# https://github.com/talonvoice/talon/issues/254#issuecomment-789355238
		# user.paste(content)</p><h2>talon helpers</h2><p>rule: talon check updates , imp:menu.check_for_updates()</p><p>rule: talon open log , imp:menu.open_log()</p><p>rule: talon open rebel , imp:menu.open_repl()</p><p>rule: talon home , imp:menu.open_talon_home()</p><p>rule: talon copy context pie , imp:user.talon_add_context_clipboard_python()</p><p>rule: talon copy context , imp:user.talon_add_context_clipboard()</p><p>rule: talon copy name , imp:name = app.name()
		clip.set_text(name)</p><p>rule: talon copy executable , imp:executable = app.executable()
		clip.set_text(executable)</p><p>rule: talon copy bundle , imp:bundle = app.bundle()
		clip.set_text(bundle)</p><p>rule: talon copy title , imp:title = win.title()
		clip.set_text(title)</p><p>rule: talon dump version , imp:result = user.talon_version_info()
		print(result)</p><p>rule: talon insert version , imp:result = user.talon_version_info()
		user.paste(result)</p><p>rule: talon dump context , imp:result = user.talon_get_active_context()
		print(result)</p><p>rule: talon test last , imp:phrase = user.history_get(1)
		user.talon_sim_phrase(phrase)</p><p>rule: talon test numb &lt;number_small&gt; , imp:phrase = user.history_get(number_small)
		user.talon_sim_phrase(phrase)</p><p>rule: talon test &lt;phrase&gt; , imp:user.talon_sim_phrase(phrase)</p><p>rule: talon debug action {user.talon_actions} , imp:user.talon_action_find("{user.talon_actions}")</p><p>rule: talon debug list {user.talon_lists} , imp:user.talon_debug_list(talon_lists)</p><p>rule: talon copy list {user.talon_lists} , imp:user.talon_copy_list(talon_lists)</p><p>rule: talon debug tags , imp:user.talon_debug_tags()</p><p>rule: talon debug modes , imp:user.talon_debug_modes()</p><p>rule: talon debug scope {user.talon_scopes} , imp:user.talon_debug_scope(talon_scopes)</p><p>rule: talon debug setting {user.talon_settings} , imp:user.talon_debug_setting(talon_settings)</p><p>rule: talon debug all settings , imp:user.talon_debug_all_settings()</p><p>rule: talon debug active app , imp:result = user.talon_get_active_application_info()
		print("**** Dumping active application **** ")
		print(result)
		print("***********************")</p><p>rule: talon copy active app , imp:result = user.talon_get_active_application_info()
		clip.set_text(result)
		</p><p>rule: talon create app context , imp:user.talon_create_app_context()</p><p>rule: talon create windows app context , imp:user.talon_create_app_context("win")</p><p>rule: talon create linux app context , imp:user.talon_create_app_context("linux")</p><p>rule: talon create mac app context , imp:user.talon_create_app_context("mac")</p><p>rule: talon (bug report | report bug) , imp:user.open_url("https://github.com/talonhub/community/issues")</p><p style="page-break-after: always;">&nbsp;</p><h2>text navigation</h2><p>rule: navigate [{user.arrow_key}] [{user.navigation_action}] [{user.navigation_target_name}] [{user.before_or_after}] [&lt;user.ordinals&gt;] &lt;user.navigation_target&gt; , imp:## If you use this command a lot, you may wish to have a shorter syntax that omits the navigate keyword. Note that you then at least have to say either a navigation_action or before_or_after:
		#({user.navigation_action} [{user.arrow_key}] [{user.navigation_target_name}] [{user.before_or_after}] | [{user.arrow_key}] {user.before_or_after}) [&lt;user.ordinals&gt;] &lt;user.navigation_target&gt;:
		user.navigation(navigation_action or "GO", arrow_key or "RIGHT", navigation_target_name or "DEFAULT", before_or_after or "DEFAULT", navigation_target, ordinals or 1)
		
		# ===== Examples of use =====
		#
		#   navigate comma: moves after the next "," on the line.
		#   navigate before five: moves before the next "5" on the line.
		#   navigate left underscore: moves before the previous "_" on the line.
		#   navigate left after second plex: moves after the second-previous "x" on the line.
		#
		# Besides characters, we can find phrases or move in predetermined units:
		#
		#   navigate phrase hello world: moves after the next "hello world" on the line.
		#   navigate left third word: moves left over three words.
		#   navigate before second big: moves before the second-next 'big' word (a chunk of anything except white space).
		#   navigate left second small: moves left over two 'small' words (chunks of a camelCase name).
		#
		# We can search several lines (default 10) above or below the cursor:
		#
		#   navigate up phrase john: moves before the previous "john" (case-insensitive) on the preceding lines.
		#   navigate down third period: moves after the third period on the following lines.
		#
		# Besides movement, we can cut, copy, select, clear (delete), or extend the current selection:
		#
		#   navigate cut after comma: cut the word following the next comma on the line.
		#   navigate left copy third word: copy the third word to the left.
		#   navigate extend third big: extend the selection three big words right.
		#   navigate down clear phrase I think: delete the next occurrence of "I think" on the following lines.
		#   navigate up select colon: select the closest colon on the preceeding lines.
		#
		# We can specify what gets selected before or after the given input:
		#
		#    navigate select parens after equals: Select the first "(" and everything until the first ")" after the "="
		#    navigate left copy all before equals: Copy everything from the start of the line until the first "=" you encounter while moving left
		#    navigate clear constant before semicolon: Delete the last word consisting of only uppercase characters or underscores before a ";"
		#
		# ===== Explanation of the grammar =====
		#
		# [{user.arrow_key}]: left, right, up, down (default: right)
		#   Which direction to navigate in.
		#   left/right work on the current line.
		#   up/down work on the closest lines (default: 10) above or below.
		#
		# [{user.navigation_action}]: move, extend, select, clear, cut, copy (default: move)
		#   What action to perform.
		#
		# [{user.navigation_target_name}]: word, small, big, parens, squares, braces, quotes, angles, all, method, constant (default: word)
		#    The predetermined unit to select if before_or_after was specified.
		#    Defaults to "word"
		#
		# [{user.before_or_after}]: before, after (default: special behavior)
		#   For move/extend: where to leave the cursor, before or after the target.
		#   Defaults to "after" for right/down and "before" for left/up.
		#
		#   For select/copy/cut: if absent, select/copy/cut the target iself. If
		#   present, the navigation_target_name before/after the target.
		#
		# [&lt;user.ordinals&gt;]: an english ordinal, like "second" (default: first)
		#   Which occurrence of the target to navigate to.
		#
		# &lt;user.navigation_target&gt;: one of the following:
		#   - a character name, like "comma" or "five".
		#   - "word" or "big" or "small"
		#   - "phrase &lt;some text to search for&gt;"
		#   Specifies the target to search for<br>avigate to.
		
		# The functionality for all these commands is covered in the lines above, but these commands are kept here for convenience. Originally from word_selection.talon.</p><p>rule: word neck [&lt;number_small&gt;] , imp:user.navigation_by_name("SELECT", "RIGHT", "DEFAULT", "word", number_small or 1)</p><p>rule: word pre [&lt;number_small&gt;] , imp:user.navigation_by_name("SELECT", "LEFT", "DEFAULT", "word", number_small or 1)</p><p>rule: small word neck [&lt;number_small&gt;] , imp:user.navigation_by_name("SELECT", "RIGHT", "DEFAULT", "small", number_small or 1)</p><p>rule: small word pre [&lt;number_small&gt;] , imp:user.navigation_by_name("SELECT", "LEFT", "DEFAULT", "small", number_small or 1)</p><p>rule: big word neck [&lt;number_small&gt;] , imp:user.navigation_by_name("SELECT", "RIGHT", "DEFAULT", "big", number_small or 1)</p><p>rule: big word pre [&lt;number_small&gt;] , imp:user.navigation_by_name("SELECT", "LEFT", "DEFAULT", "big", number_small or 1)</p><h2>browser</h2><p>rule: address bar | go address | go url , imp:browser.focus_address()</p><p>rule: go page | page focus , imp:browser.focus_page()</p><p>rule: address copy | url copy | copy address | copy url , imp:browser.focus_address()
		sleep(50ms)
		edit.copy()</p><p>rule: go home , imp:browser.go_home()</p><p>rule: [go] forward , imp:browser.go_forward()</p><p>rule: go (back | backward) , imp:browser.go_back()</p><p>rule: go to {user.website} , imp:browser.go(website)</p><p>rule: go private , imp:browser.open_private_window()</p><p>rule: bookmark it , imp:browser.bookmark()</p><p>rule: bookmark tabs , imp:browser.bookmark_tabs()</p><p>rule: (refresh | reload) it , imp:browser.reload()</p><p>rule: (refresh | reload) it hard , imp:browser.reload_hard()</p><p>rule: bookmark show , imp:browser.bookmarks()</p><p>rule: bookmark bar [show] , imp:browser.bookmarks_bar()</p><p>rule: downloads show , imp:browser.show_downloads()</p><p>rule: extensions show , imp:browser.show_extensions()</p><p>rule: history show , imp:browser.show_history()</p><p>rule: cache show , imp:browser.show_clear_cache()</p><p>rule: dev tools [show] , imp:browser.toggle_dev_tools()</p><p>rule: show downloads , imp:browser.show_downloads()</p><p>rule: show extensions , imp:browser.show_extensions()</p><p>rule: show history , imp:browser.show_history()</p><p>rule: show cache , imp:browser.show_clear_cache()</p><p style="page-break-after: always;">&nbsp;</p><h2>chapters</h2><p>rule: chapter next , imp:user.chapter_next()</p><p>rule: chapter last , imp:user.chapter_previous()</p><p>rule: go chapter &lt;number&gt; , imp:user.chapter_jump(number)</p><p>rule: go chapter final , imp:user.chapter_final()</p><h2>debugger</h2><p>rule: step into , imp:user.debugger_step_into()</p><p>rule: step over , imp:user.debugger_step_over()</p><p>rule: step line , imp:user.debugger_step_line()</p><p>rule: step over line , imp:user.debugger_step_over_line()</p><p>rule: step out , imp:user.debugger_step_out()</p><p>rule: continue , imp:user.debugger_continue()</p><p>rule: debug start , imp:user.debugger_start()</p><p>rule: debug stop , imp:user.debugger_stop()</p><p>rule: debug exit , imp:user.debugger_exit()</p><p>rule: debug detach , imp:user.debugger_detach()</p><p>rule: debug restart , imp:user.debugger_restart()</p><p>rule: show registers , imp:user.debugger_show_registers()</p><p>rule: get register , imp:user.debugger_get_register()</p><p>rule: set register , imp:user.debugger_set_register()</p><p>rule: break now , imp:user.debugger_break_now()</p><p>rule: break here , imp:user.debugger_break_here()</p><p>rule: (list | show) (breaks | break points) , imp:user.debugger_show_breakpoints()</p><p>rule: (set | add) (break | break point) , imp:user.debugger_add_sw_breakpoint()</p><p>rule: (set | add) hardware (break | break point) , imp:user.debugger_add_hw_breakpoint()</p><p>rule: clear all (breaks | break points) , imp:user.debugger_clear_all_breakpoints()</p><p>rule: clear (break | break point) , imp:user.debugger_clear_breakpoint()</p><p>rule: clear (break | break point) &lt;number_small&gt; , imp:user.debugger_clear_breakpoint_id(number_small)</p><p>rule: disable all (breaks | break points) , imp:user.debugger_disable_all_breakpoints()</p><p>rule: disable (break | break point) , imp:user.debugger_disable_breakpoint()</p><p>rule: disable (break | break point) &lt;number_small&gt; , imp:user.debugger_disable_breakpoint_id(number_small)</p><p>rule: enable all (breaks | break points) , imp:user.debugger_enable_all_breakpoints()</p><p>rule: enable (break | break point) , imp:user.debugger_enable_breakpoint()</p><p>rule: enable (break | break point) &lt;number_small&gt; , imp:user.debugger_enable_breakpoint_id(number_small)
		
		# Navigation
		
		# Memory Inspection</p><p>rule: (stack | back) trace , imp:user.debugger_backtrace()</p><p>rule: disassemble , imp:user.debugger_disassemble()</p><p>rule: disassemble here , imp:user.debugger_disassemble_here()</p><p>rule: disassemble clipboard , imp:user.debugger_disassemble_clipboard()</p><p>rule: jump to address , imp:user.debugger_goto_address()</p><p>rule: jump to clipboard , imp:user.debugger_goto_clipboard()</p><p>rule: jump to highlighted , imp:user.debugger_goto_highlighted()</p><p>rule: dump string , imp:user.debugger_dump_ascii_string()</p><p>rule: dump unicode [string] , imp:user.debugger_dump_unicode_string()</p><p>rule: dump pointers , imp:user.debugger_dump_pointers()</p><p>rule: list modules , imp:user.debugger_list_modules()</p><p>rule: inspect type , imp:user.debugger_inspect_type()</p><p>rule: clear line , imp:user.debugger_clear_line()</p><p style="page-break-after: always;">&nbsp;</p><h2>emoji</h2><p>rule: emoticon {user.emoticon} , imp:"{emoticon}"</p><p>rule: emoji {user.emoji} , imp:user.paste(emoji)</p><p>rule: kaomoji {user.kaomoji} , imp:user.paste(kaomoji)</p><h2>file manager</h2><p>rule: title force , imp:user.file_manager_refresh_title()</p><p>rule: manager show , imp:user.file_manager_toggle_pickers()</p><p>rule: manager close , imp:user.file_manager_hide_pickers()</p><p>rule: manager refresh , imp:user.file_manager_update_lists()</p><p>rule: go &lt;user.system_path&gt; , imp:user.file_manager_open_directory(system_path)</p><p>rule: go back , imp:user.file_manager_go_back()</p><p>rule: go forward , imp:user.file_manager_go_forward()</p><p>rule: (go parent | daddy) , imp:user.file_manager_open_parent()</p><p>rule: follow numb &lt;number_small&gt; , imp:directory = user.file_manager_get_directory_by_index(number_small - 1)
		user.file_manager_open_directory(directory)</p><p>rule: follow {user.file_manager_directories} , imp:user.file_manager_open_directory(file_manager_directories)</p><p>rule: (select | cell) folder {user.file_manager_directories} , imp:user.file_manager_select_directory(file_manager_directories)</p><p>rule: open &lt;number_small&gt; , imp:file = user.file_manager_get_file_by_index(number_small - 1)
		user.file_manager_open_file(file)</p><p>rule: folder numb &lt;number_small&gt; , imp:directory = user.file_manager_get_directory_by_index(number_small - 1)
		user.file_manager_select_directory(directory)</p><p>rule: file numb &lt;number_small&gt; , imp:file = user.file_manager_get_file_by_index(number_small - 1)
		user.file_manager_select_file(file)</p><p>rule: file {user.file_manager_files} , imp:user.file_manager_select_file(file_manager_files)</p><p>rule: (select | cell) file {user.file_manager_files} , imp:user.file_manager_select_file(file_manager_files)
		
		#new folder</p><p>rule: folder new &lt;user.text&gt; , imp:user.file_manager_new_folder(text)</p><p>rule: properties show , imp:user.file_manager_show_properties()</p><p>rule: terminal here , imp:user.file_manager_terminal_here()</p><p>rule: folder next , imp:user.file_manager_next_folder_page()</p><p>rule: folder last , imp:user.file_manager_previous_folder_page()</p><p>rule: file next , imp:user.file_manager_next_file_page()</p><p>rule: file last , imp:user.file_manager_previous_file_page()</p><p style="page-break-after: always;">&nbsp;</p><h2>find and replace</h2><p>rule: hunt this , imp:user.find("")</p><p>rule: hunt this (pace | paste) , imp:user.find("")
		sleep(25ms)
		edit.paste()</p><p>rule: hunt this &lt;user.text&gt; , imp:user.find(text)</p><p>rule: hunt all , imp:user.find_everywhere("")</p><p>rule: hunt all (pace | paste) , imp:user.find_everywhere("")
		sleep(25ms)
		edit.paste()</p><p>rule: hunt all &lt;user.text&gt; , imp:user.find_everywhere(text)</p><p>rule: hunt case , imp:user.find_toggle_match_by_case()</p><p>rule: hunt word , imp:user.find_toggle_match_by_word()</p><p>rule: hunt expression , imp:user.find_toggle_match_by_regex()</p><p>rule: hunt next , imp:user.find_next()</p><p>rule: hunt previous , imp:user.find_previous()</p><p>rule: replace this [&lt;user.text&gt;] , imp:user.replace(text or "")</p><p>rule: replace all , imp:user.replace_everywhere("")</p><p>rule: replace &lt;user.text&gt; all , imp:user.replace_everywhere(text)</p><p>rule: replace confirm that , imp:user.replace_confirm()</p><p>rule: replace confirm all , imp:user.replace_confirm_all()</p><p>rule: clear last &lt;user.text&gt; [over] , imp:user.select_previous_occurrence(text)
		sleep(100ms)
		edit.delete()</p><p>rule: clear next &lt;user.text&gt; [over] , imp:user.select_next_occurrence(text)
		sleep(100ms)
		edit.delete()</p><p>rule: clear last clip , imp:user.select_previous_occurrence(clip.text())
		edit.delete()</p><p>rule: clear next clip , imp:user.select_next_occurrence(clip.text())
		sleep(100ms)
		edit.delete()</p><p>rule: comment last &lt;user.text&gt; [over] , imp:user.select_previous_occurrence(text)
		sleep(100ms)
		code.toggle_comment()</p><p>rule: comment last clip , imp:user.select_previous_occurrence(clip.text())
		sleep(100ms)
		code.toggle_comment()</p><p>rule: comment next &lt;user.text&gt; [over] , imp:user.select_next_occurrence(text)
		sleep(100ms)
		code.toggle_comment()</p><p>rule: comment next clip , imp:user.select_next_occurrence(clip.text())
		sleep(100ms)
		code.toggle_comment()</p><p>rule: go last &lt;user.text&gt; [over] , imp:user.select_previous_occurrence(text)
		sleep(100ms)
		edit.right()</p><p>rule: go last clip , imp:user.select_previous_occurrence(clip.text())
		sleep(100ms)
		edit.right()</p><p>rule: go next &lt;user.text&gt; [over] , imp:user.select_next_occurrence(text)
		edit.right()</p><p>rule: go next clip , imp:user.select_next_occurrence(clip.text())
		edit.right()</p><p>rule: paste last &lt;user.text&gt; [over] , imp:user.select_previous_occurrence(text)
		sleep(100ms)
		edit.right()
		edit.paste()</p><p>rule: paste next &lt;user.text&gt; [over] , imp:user.select_next_occurrence(text)
		sleep(100ms)
		edit.right()
		edit.paste()</p><p>rule: replace last &lt;user.text&gt; [over] , imp:user.select_previous_occurrence(text)
		sleep(100ms)
		edit.paste()</p><p>rule: replace next &lt;user.text&gt; [over] , imp:user.select_next_occurrence(text)
		sleep(100ms)
		edit.paste()</p><p>rule: select last &lt;user.text&gt; [over] , imp:user.select_previous_occurrence(text)</p><p>rule: select next &lt;user.text&gt; [over] , imp:user.select_next_occurrence(text)</p><p>rule: select last clip , imp:user.select_previous_occurrence(clip.text())</p><p>rule: select next clip , imp:user.select_next_occurrence(clip.text())</p><p style="page-break-after: always;">&nbsp;</p><h2>line commands</h2><p>rule: lend , imp:edit.line_end()</p><p>rule: bend , imp:edit.line_start()</p><p>rule: go &lt;number&gt; , imp:edit.jump_line(number)</p><p>rule: go &lt;number&gt; end , imp:edit.jump_line(number)
		edit.line_end()</p><p>rule: comment [line] &lt;number&gt; , imp:user.select_range(number, number)
		code.toggle_comment()</p><p>rule: comment &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		code.toggle_comment()</p><p>rule: clear [line] &lt;number&gt; , imp:user.select_range(number, number)
		edit.delete()</p><p>rule: clear &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		edit.delete()</p><p>rule: copy [line] &lt;number&gt; , imp:user.select_range(number, number)
		edit.copy()</p><p>rule: copy &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		edit.copy()</p><p>rule: cut [line] &lt;number&gt; , imp:user.select_range(number, number)
		edit.cut()</p><p>rule: cut [line] &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		edit.cut()</p><p>rule: (paste | replace) &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		edit.paste()</p><p>rule: (select | cell | sell) [line] &lt;number&gt; , imp:user.select_range(number, number)</p><p>rule: (select | cell | sell) &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)</p><p>rule: tab that , imp:edit.indent_more()</p><p>rule: tab [line] &lt;number&gt; , imp:edit.jump_line(number)
		edit.indent_more()</p><p>rule: tab &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		edit.indent_more()</p><p>rule: retab that , imp:edit.indent_less()</p><p>rule: retab [line] &lt;number&gt; , imp:user.select_range(number, number)
		edit.indent_less()</p><p>rule: retab &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		edit.indent_less()</p><p>rule: drag [line] down , imp:edit.line_swap_down()</p><p>rule: drag [line] up , imp:edit.line_swap_up()</p><p>rule: drag up [line] &lt;number&gt; , imp:user.select_range(number, number)
		edit.line_swap_up()</p><p>rule: drag up &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		edit.line_swap_up()</p><p>rule: drag down [line] &lt;number&gt; , imp:user.select_range(number, number)
		edit.line_swap_down()</p><p>rule: drag down &lt;number&gt; until &lt;number&gt; , imp:user.select_range(number_1, number_2)
		edit.line_swap_down()</p><p>rule: clone [line] &lt;number&gt; , imp:user.line_clone(number)</p><p>rule: select camel left , imp:user.extend_camel_left()</p><p>rule: select camel right , imp:user.extend_camel_right()</p><p>rule: go camel left , imp:user.camel_left()</p><p>rule: go camel right , imp:user.camel_right()</p><p style="page-break-after: always;">&nbsp;</p><h2>messaging</h2><p>rule: previous (workspace | server) , imp:user.messaging_workspace_previous()</p><p>rule: next (workspace | server) , imp:user.messaging_workspace_next()</p><p>rule: channel , imp:user.messaging_open_channel_picker()</p><p>rule: channel &lt;user.text&gt; , imp:user.messaging_open_channel_picker()
		insert(user.formatted_text(user.text, "ALL_LOWERCASE"))</p><p>rule: channel up , imp:user.messaging_channel_previous()</p><p>rule: channel down , imp:user.messaging_channel_next()</p><p>rule: ([channel] unread last | gopreev) , imp:user.messaging_unread_previous()</p><p>rule: ([channel] unread next | goneck) , imp:user.messaging_unread_next()</p><p>rule: go (find | search) , imp:user.messaging_open_search()</p><p>rule: mark (all | workspace | server) read , imp:user.messaging_mark_workspace_read()</p><p>rule: mark channel read , imp:user.messaging_mark_channel_read()</p><p>rule: upload file , imp:user.messaging_upload_file()</p><h2>multiple cursors</h2><p>rule: cursor multiple , imp:user.multi_cursor_enable()</p><p>rule: cursor stop , imp:user.multi_cursor_disable()</p><p>rule: cursor up , imp:user.multi_cursor_add_above()</p><p>rule: cursor down , imp:user.multi_cursor_add_below()</p><p>rule: cursor less , imp:user.multi_cursor_select_fewer_occurrences()</p><p>rule: cursor more , imp:user.multi_cursor_select_more_occurrences()</p><p>rule: cursor skip , imp:user.multi_cursor_skip_occurrence()</p><p>rule: cursor all , imp:user.multi_cursor_select_all_occurrences()</p><p>rule: cursor lines , imp:user.multi_cursor_add_to_line_ends()</p><p style="page-break-after: always;">&nbsp;</p><h2>pages</h2><p>rule: page next , imp:user.page_next()</p><p>rule: page last , imp:user.page_previous()</p><p>rule: go page &lt;number&gt; , imp:user.page_jump(number)</p><p>rule: go page final , imp:user.page_final()</p><h2>splits</h2><p>rule: split right , imp:user.split_window_right()</p><p>rule: split left , imp:user.split_window_left()</p><p>rule: split down , imp:user.split_window_down()</p><p>rule: split up , imp:user.split_window_up()</p><p>rule: split (vertically | vertical) , imp:user.split_window_vertically()</p><p>rule: split (horizontally | horizontal) , imp:user.split_window_horizontally()</p><p>rule: split flip , imp:user.split_flip()</p><p>rule: split max , imp:user.split_maximize()</p><p>rule: split reset , imp:user.split_reset()</p><p>rule: split window , imp:user.split_window()</p><p>rule: split clear , imp:user.split_clear()</p><p>rule: split clear all , imp:user.split_clear_all()</p><p>rule: split next , imp:user.split_next()</p><p>rule: split last , imp:user.split_last()</p><p>rule: go split &lt;number&gt; , imp:user.split_number(number)</p><h2>terminal</h2><p>rule: lisa , imp:user.terminal_list_directories()</p><p>rule: lisa all , imp:user.terminal_list_all_directories()</p><p>rule: katie [dir] [&lt;user.text&gt;] , imp:user.terminal_change_directory(text or "")</p><p>rule: katie root , imp:user.terminal_change_directory_root()</p><p>rule: katie (up | back) , imp:user.terminal_change_directory("..")</p><p>rule: go &lt;user.system_path&gt; , imp:insert('cd "{system_path}"\n')</p><p>rule: path &lt;user.system_path&gt; , imp:insert('"{system_path}"')</p><p>rule: clear screen , imp:user.terminal_clear_screen()</p><p>rule: run last , imp:user.terminal_run_last()</p><p>rule: rerun [&lt;user.text&gt;] , imp:user.terminal_rerun_search(text or "")</p><p>rule: rerun search , imp:user.terminal_rerun_search("")</p><p>rule: kill all , imp:user.terminal_kill_all()</p><p>rule: copy paste , imp:edit.copy()
		sleep(50ms)
		edit.paste()</p><p style="page-break-after: always;">&nbsp;</p><h2>unix utilities</h2><p>rule: core {user.unix_utility} , imp:"{unix_utility} "</p><h2>gaze ocr</h2><p>rule: (eye | i) (hover | [cursor] move) , imp:user.move_cursor_to_gaze_point()</p><p>rule: (eye | i) [left] (touch | click) , imp:user.move_cursor_to_gaze_point()
		mouse_click(0)</p><p>rule: (eye | i) [left] double (touch | click) , imp:user.move_cursor_to_gaze_point()
		mouse_click(0)
		mouse_click(0)</p><p>rule: (eye | i) right (touch | click) , imp:user.move_cursor_to_gaze_point()
		mouse_click(1)</p><p>rule: (eye | i) middle (touch | click) , imp:user.move_cursor_to_gaze_point()
		mouse_click(2)
		# Example: "eye control click" to control-click where you're looking.</p><p>rule: (eye | i) &lt;user.modifiers&gt; (touch | click) , imp:user.move_cursor_to_gaze_point()
		key("{modifiers}:down")
		mouse_click(0)
		key("{modifiers}:up")
		</p><p>rule: (eye | i) scroll up , imp:user.move_cursor_to_gaze_point(0, 40)
		user.mouse_scroll_up()</p><p>rule: (eye | i) scroll up half , imp:user.move_cursor_to_gaze_point(0, 40)
		user.mouse_scroll_up(0.5)</p><p>rule: (eye | i) scroll down , imp:user.move_cursor_to_gaze_point(0, -40)
		user.mouse_scroll_down()</p><p>rule: (eye | i) scroll down half , imp:user.move_cursor_to_gaze_point(0, -40)
		user.mouse_scroll_down(0.5)</p><p>rule: (eye | i) scroll left , imp:user.move_cursor_to_gaze_point(40, 0)
		user.mouse_scroll_left()</p><p>rule: (eye | i) scroll left half , imp:user.move_cursor_to_gaze_point(40, 0)
		user.mouse_scroll_left(0.5)</p><p>rule: (eye | i) scroll right , imp:user.move_cursor_to_gaze_point(-40, 0)
		user.mouse_scroll_right()</p><p>rule: (eye | i) scroll right half , imp:user.move_cursor_to_gaze_point(-40, 0)
		user.mouse_scroll_right(0.5)
		
		# Debugging commands.</p><p>rule: ocr show [text] , imp:user.show_ocr_overlay("text", 1)</p><p>rule: ocr show boxes , imp:user.show_ocr_overlay("boxes", 1)</p><p>rule: (hover (seen | scene) | cursor move) &lt;user.timestamped_prose&gt; , imp:user.move_cursor_to_word(timestamped_prose)</p><p>rule: [left] (touch | click) &lt;user.timestamped_prose&gt; , imp:user.click_text(timestamped_prose)</p><p>rule: [left] double (touch | click) &lt;user.timestamped_prose&gt; , imp:user.double_click_text(timestamped_prose)</p><p>rule: right (touch | click) &lt;user.timestamped_prose&gt; , imp:user.right_click_text(timestamped_prose)</p><p>rule: middle (touch | click) &lt;user.timestamped_prose&gt; , imp:user.middle_click_text(timestamped_prose)</p><p>rule: &lt;user.modifiers&gt; (touch | click) &lt;user.timestamped_prose&gt; , imp:user.modifier_click_text(modifiers, timestamped_prose)
		# Example: "go before apple" to move the text cursor before the word "apple".</p><p>rule: (go before | pre (seen | scene)) &lt;user.timestamped_prose&gt; , imp:user.move_text_cursor_to_word(timestamped_prose, "before")</p><p>rule: (go after | post (seen | scene)) &lt;user.timestamped_prose&gt; , imp:user.move_text_cursor_to_word(timestamped_prose, "after")</p><p>rule: select &lt;user.prose_range&gt; , imp:user.perform_ocr_action("select", "", prose_range)
		# Examples:
		# "take seen apple" to select the word "apple".
		# "copy seen apple through banana" to copy the phrase "apple pear banana".
		# "copy all seen apple" to copy all text from the field containing the word "apple".</p><p>rule: {user.ocr_actions} [{user.ocr_modifiers}] (seen | scene) &lt;user.prose_range&gt; , imp:user.perform_ocr_action(ocr_actions, ocr_modifiers or "", prose_range)
		# Example: "replace apple with banana" to replace the word "apple" with the word "banana".</p><p>rule: replace [{user.ocr_modifiers}] [seen | scene] &lt;user.prose_range&gt; with &lt;user.prose&gt; , imp:user.replace_text(ocr_modifiers or "", prose_range, prose)</p><p>rule: [go] before &lt;user.timestamped_prose&gt; say &lt;user.prose&gt; , imp:user.insert_adjacent_to_text(timestamped_prose, "before", prose)</p><p>rule: [go] after &lt;user.timestamped_prose&gt; say &lt;user.prose&gt; , imp:user.insert_adjacent_to_text(timestamped_prose, "after", prose)</p><p>rule: phones (seen | scene) &lt;user.timestamped_prose&gt; , imp:user.change_text_homophone(timestamped_prose)
		</p><p>rule: ocr tracker on , imp:user.connect_ocr_eye_tracker()</p><p>rule: ocr tracker off , imp:user.disconnect_ocr_eye_tracker()</p><p style="page-break-after: always;">&nbsp;</p><h2>gaze ocr disambiguation</h2><p>rule: choose &lt;number_small&gt; , imp:user.choose_gaze_ocr_option(number_small)</p><p>rule: choose to , imp:user.choose_gaze_ocr_option(2)</p><p>rule: numbers hide , imp:user.hide_gaze_ocr_options()</p><h2>cheatsheet</h2><p>rule: print cheatsheet , imp:user.cheatsheet()</p>